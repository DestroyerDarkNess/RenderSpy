<?xml version="1.0"?>
<doc>
    <assembly>
        <name>SharpDX.DirectManipulation</name>
    </assembly>
    <members>
        <member name="M:SharpDX.DirectManipulation.AutoScrollBehavior.SetConfiguration(SharpDX.DirectManipulation.MotionTypes,SharpDX.DirectManipulation.AutoScrollConfiguration)">
            <summary>
            <p>Performs the auto-scroll animation for the viewport this behavior is attached to. </p>
            </summary>
            <param name = "motionTypes"><dd> <p>A combination of <strong>DIRECTMANIPULATION_MOTION_TRANSLATEX</strong> and <strong>DIRECTMANIPULATION_MOTION_TRANSLATEY</strong> from <strong><see cref = "T:SharpDX.DirectManipulation.MotionTypes"/></strong>. <strong>DIRECTMANIPULATION_MOTION_NONE</strong> cannot be specified.</p> </dd></param>
            <param name = "scrollMotion"><dd> <p>One of the values from <strong><see cref = "T:SharpDX.DirectManipulation.AutoScrollConfiguration"/></strong>. </p> </dd></param>
            <returns><p>If the method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p><strong>SetConfiguration</strong> takes effect immediately. If the content is not in inertia, and <strong>DIRECTMANIPULATION_AUTOSCROLL_CONFIGURATION_STOP</strong> is specified for <em>scrollMotion</em>, then this method returns S_FALSE. </p>
            </remarks>
            <doc-id>dn280388</doc-id>
            <unmanaged>HRESULT IDirectManipulationAutoScrollBehavior::SetConfiguration([In] DIRECTMANIPULATION_MOTION_TYPES motionTypes,[In] DIRECTMANIPULATION_AUTOSCROLL_CONFIGURATION scrollMotion)</unmanaged>
            <unmanaged-short>IDirectManipulationAutoScrollBehavior::SetConfiguration</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectManipulation.Compositor.AddContent(SharpDX.DirectManipulation.Content,SharpDX.ComObject,SharpDX.ComObject,SharpDX.ComObject)">
            <summary>	
            <p>Associates content with the compositor, assigns a composition device to the content, and specifies the position of the content in the composition tree relative to other composition visuals. </p>Syntax<pre><see cref="T:SharpDX.Result" /> AddContent( [in]????????????<see cref="T:SharpDX.DirectManipulation.Content" /> *content, [in, optional]??<see cref="T:SharpDX.ComObject" />   device, [in]????????????<see cref="T:SharpDX.ComObject" /> *parentVisual, [in]????????????<see cref="T:SharpDX.ComObject" /> *childVisual	
            );</pre>Parameters<dl> <dt><em>content</em> [in]</dt> <dd> <p>The content to add to the composition tree.</p> <p><em>content</em> is placed  between <em>parentVisual</em> and <em>childVisual</em> in the composition tree. </p> </dd> <dt><em> device</em> [in, optional]</dt> <dd> <p>The device used to compose the content. </p> <p><strong>Note</strong>??<em>device</em> is created by the application.</p> </dd> <dt><em>parentVisual</em> [in]</dt> <dd> <p>The parent in the composition tree for the content being added.</p> <p><em>parentVisual</em> must also be a parent of <em>childVisual</em> in the composition tree.</p> </dd> <dt><em>childVisual</em> [in]</dt> <dd> <p>The child in the composition tree for the content being added.</p> <p><em>parentVisual</em> must also be a parent of <em>childVisual</em> in the composition tree.</p> </dd> </dl>Return value<p>If the method succeeds, it returns <strong><see cref="F:SharpDX.Result.Ok" /></strong>. Otherwise, it returns an <strong><see cref="T:SharpDX.Result" /></strong> error code.</p>Remarks<p>All content, regardless of type, must be added to the compositor. This can be primary content, obtained from the viewport by calling <strong>GetPrimaryContent</strong>, or secondary content, such as a panning indicator, created by calling <strong>CreateContent</strong>.	
            </p><p>If the application uses a system-provided <strong><see cref="T:SharpDX.DirectManipulation.Compositor" /></strong>:</p><ul> <li><em>device</em> must be an  <strong><see cref="!:SharpDX.DirectComposition.Device" /></strong> object, and parent and child visuals must be <strong><see cref="!:SharpDX.DirectComposition.Visual" /></strong> objects.</li> <li><em>device</em>, <em>parentVisual</em>, and <em>childVisual</em> cannot be <c>null</c>. </li> <li><em>device</em>, <em>parentVisual</em>, and <em>childVisual</em> objects are created and owned by the application.	
            </li> <li>When content is added to the composition tree using this method, the new composition visuals are inserted between <em>parentVisual</em> and <em>childVisual</em>. The new visuals should not be destroyed until they are disassociated from the compositor with <strong>RemoveContent</strong>.</li> </ul><p>If the application uses a custom implementation of <strong><see cref="T:SharpDX.DirectManipulation.Compositor" /></strong>:</p><ul> <li><em>device</em>, <em>parentVisual</em>, and <em>childVisual</em> must be a valid type for the compositor. They do not have to be <strong><see cref="!:SharpDX.DirectComposition.Device" /></strong> or <strong><see cref="!:SharpDX.DirectComposition.Visual" /></strong> objects.</li> <li><em>device</em>, <em>parentVisual</em>, and <em>childVisual</em> can be <c>null</c>, depending on the compositor. </li> </ul>Requirements	
            </summary>	
            <param name="content"><dd> <p>The content to add to the composition tree.</p> <p><em>content</em> is placed  between <em>parentVisual</em> and <em>childVisual</em> in the composition tree. </p> </dd></param>	
            <param name="device"><dd> <p>The device used to compose the content. </p> <p><strong>Note</strong>??<em>device</em> is created by the application.</p> </dd></param>	
            <param name="arentVisualRef"><dd> <p>The parent in the composition tree for the content being added.</p> <p><em>parentVisual</em> must also be a parent of <em>childVisual</em> in the composition tree.</p> </dd></param>	
            <param name="childVisual"><dd> <p>The child in the composition tree for the content being added.</p> <p><em>parentVisual</em> must also be a parent of <em>childVisual</em> in the composition tree.</p> </dd></param>	
            <returns>No documentation.</returns>	
            <!-- No matching elements were found for the following include tag --><include file="Documentation\CodeComments.xml" path="/comments/comment[@id='IDirectManipulationCompositor::AddContent']/*" />	
            <msdn-id>Hh768898</msdn-id>	
            <unmanaged>HRESULT IDirectManipulationCompositor::AddContent([In] IDirectManipulationContent* content,[In, Optional] IUnknown* device,[In, Optional] IUnknown* parentVisual,[In, Optional] IUnknown* childVisual)</unmanaged>	
            <unmanaged-short>IDirectManipulationCompositor::AddContent</unmanaged-short>	
        </member>
        <member name="M:SharpDX.DirectManipulation.Compositor.RemoveContent(SharpDX.DirectManipulation.Content)">
            <summary>	
            <p>Removes content from the compositor.</p>Syntax<pre><see cref="T:SharpDX.Result" /> RemoveContent( [in]??<see cref="T:SharpDX.DirectManipulation.Content" /> *content	
            );</pre>Parameters<dl> <dt><em>content</em> [in]</dt> <dd> <p>The content to remove from the composition tree.</p> </dd> </dl>Return value<p>If the method succeeds, it returns <strong><see cref="F:SharpDX.Result.Ok" /></strong>. Otherwise, it returns an <strong><see cref="T:SharpDX.Result" /></strong> error code.</p>Remarks<p>This method removes content added with <strong>AddContent</strong> and restores the original relationships between parent visuals and child visuals in the composition tree. In other words, <strong>RemoveContent</strong> undoes <strong>AddContent</strong>.</p>Requirements	
            </summary>	
            <param name="content"><dd> <p>The content to remove from the composition tree.</p> </dd></param>	
            <returns>No documentation.</returns>	
            <!-- No matching elements were found for the following include tag --><include file="Documentation\CodeComments.xml" path="/comments/comment[@id='IDirectManipulationCompositor::RemoveContent']/*" />	
            <msdn-id>Hh768899</msdn-id>	
            <unmanaged>HRESULT IDirectManipulationCompositor::RemoveContent([In] IDirectManipulationContent* content)</unmanaged>	
            <unmanaged-short>IDirectManipulationCompositor::RemoveContent</unmanaged-short>	
        </member>
        <member name="M:SharpDX.DirectManipulation.Compositor.SetUpdateManager(SharpDX.DirectManipulation.UpdateManager)">
            <summary>	
            <p> </p><p> Sets the update manager used to send compositor updates to Direct Manipulation. </p>Syntax<pre><see cref="T:SharpDX.Result" /> SetUpdateManager( [in]??<see cref="T:SharpDX.DirectManipulation.UpdateManager" /> *updateManager	
            );</pre>Parameters<dl> <dt><em>updateManager</em> [in]</dt> <dd> <p>The <strong>update manager</strong>.</p> </dd> </dl>Return value<p>If the method succeeds, it returns <strong><see cref="F:SharpDX.Result.Ok" /></strong>. Otherwise, it returns an <strong><see cref="T:SharpDX.Result" /></strong> error code.</p>Remarks<p>Retrieve <em>updateManager</em> by calling <strong>GetUpdateManager</strong>.</p><p>Call this method during Direct Manipulation initialization to connect the compositor to the <em>update manager</em>.</p>Requirements	
            </summary>	
            <param name="updateManager">No documentation.</param>	
            <returns>No documentation.</returns>	
            <!-- No matching elements were found for the following include tag --><include file="Documentation\CodeComments.xml" path="/comments/comment[@id='IDirectManipulationCompositor::SetUpdateManager']/*" />	
            <msdn-id>Hh768900</msdn-id>	
            <unmanaged>HRESULT IDirectManipulationCompositor::SetUpdateManager([In] IDirectManipulationUpdateManager* updateManager)</unmanaged>	
            <unmanaged-short>IDirectManipulationCompositor::SetUpdateManager</unmanaged-short>	
        </member>
        <member name="M:SharpDX.DirectManipulation.Compositor.Flush">
            <summary>	
            <p>Commits all pending updates in the compositor to the system for rendering.</p>Syntax<pre><see cref="T:SharpDX.Result" /> Flush();</pre>Parameters<p>This method has no parameters.</p>Return value<p>If the method succeeds, it returns <strong><see cref="F:SharpDX.Result.Ok" /></strong>. Otherwise, it returns an <strong><see cref="T:SharpDX.Result" /></strong> error code.</p>Remarks<p>This method enables Direct Manipulation to flush any pending changes to its visuals before a system event, such as a process suspension.</p>Requirements	
            </summary>	
            <returns>No documentation.</returns>	
            <!-- No matching elements were found for the following include tag --><include file="Documentation\CodeComments.xml" path="/comments/comment[@id='IDirectManipulationCompositor::Flush']/*" />	
            <msdn-id>jj647930</msdn-id>	
            <unmanaged>HRESULT IDirectManipulationCompositor::Flush()</unmanaged>	
            <unmanaged-short>IDirectManipulationCompositor::Flush</unmanaged-short>	
        </member>
        <member name="F:SharpDX.DirectManipulation.CompositorNative.DirectCompositionCompositorClassId">
            <summary>
            Class ID for compositor
            </summary>
        </member>
        <member name="M:SharpDX.DirectManipulation.CompositorNative.CreateDefaultDirectCompositor">
            <summary>
            Creates a default implementation of IDirectManipulationCompositor that wraps a DirectComposition render tree.
            </summary>
            <returns></returns>
        </member>
        <member name="M:SharpDX.DirectManipulation.CompositorNative.AddContent(SharpDX.DirectManipulation.Content,SharpDX.ComObject,SharpDX.ComObject,SharpDX.ComObject)">
            <summary>	
            <p>Associates content with the compositor, assigns a composition device to the content, and specifies the position of the content in the composition tree relative to other composition visuals. </p>Syntax<pre><see cref="T:SharpDX.Result" /> AddContent( [in]????????????<see cref="T:SharpDX.DirectManipulation.Content" /> *content, [in, optional]??<see cref="T:SharpDX.ComObject" />   device, [in]????????????<see cref="T:SharpDX.ComObject" /> *parentVisual, [in]????????????<see cref="T:SharpDX.ComObject" /> *childVisual	
            );</pre>Parameters<dl> <dt><em>content</em> [in]</dt> <dd> <p>The content to add to the composition tree.</p> <p><em>content</em> is placed  between <em>parentVisual</em> and <em>childVisual</em> in the composition tree. </p> </dd> <dt><em> device</em> [in, optional]</dt> <dd> <p>The device used to compose the content. </p> <p><strong>Note</strong>??<em>device</em> is created by the application.</p> </dd> <dt><em>parentVisual</em> [in]</dt> <dd> <p>The parent in the composition tree for the content being added.</p> <p><em>parentVisual</em> must also be a parent of <em>childVisual</em> in the composition tree.</p> </dd> <dt><em>childVisual</em> [in]</dt> <dd> <p>The child in the composition tree for the content being added.</p> <p><em>parentVisual</em> must also be a parent of <em>childVisual</em> in the composition tree.</p> </dd> </dl>Return value<p>If the method succeeds, it returns <strong><see cref="F:SharpDX.Result.Ok" /></strong>. Otherwise, it returns an <strong><see cref="T:SharpDX.Result" /></strong> error code.</p>Remarks<p>All content, regardless of type, must be added to the compositor. This can be primary content, obtained from the viewport by calling <strong>GetPrimaryContent</strong>, or secondary content, such as a panning indicator, created by calling <strong>CreateContent</strong>.	
            </p><p>If the application uses a system-provided <strong><see cref="T:SharpDX.DirectManipulation.Compositor" /></strong>:</p><ul> <li><em>device</em> must be an  <strong><see cref="!:SharpDX.DirectComposition.Device" /></strong> object, and parent and child visuals must be <strong><see cref="!:SharpDX.DirectComposition.Visual" /></strong> objects.</li> <li><em>device</em>, <em>parentVisual</em>, and <em>childVisual</em> cannot be <c>null</c>. </li> <li><em>device</em>, <em>parentVisual</em>, and <em>childVisual</em> objects are created and owned by the application.	
            </li> <li>When content is added to the composition tree using this method, the new composition visuals are inserted between <em>parentVisual</em> and <em>childVisual</em>. The new visuals should not be destroyed until they are disassociated from the compositor with <strong>RemoveContent</strong>.</li> </ul><p>If the application uses a custom implementation of <strong><see cref="T:SharpDX.DirectManipulation.Compositor" /></strong>:</p><ul> <li><em>device</em>, <em>parentVisual</em>, and <em>childVisual</em> must be a valid type for the compositor. They do not have to be <strong><see cref="!:SharpDX.DirectComposition.Device" /></strong> or <strong><see cref="!:SharpDX.DirectComposition.Visual" /></strong> objects.</li> <li><em>device</em>, <em>parentVisual</em>, and <em>childVisual</em> can be <c>null</c>, depending on the compositor. </li> </ul>Requirements	
            </summary>	
            <param name="content"><dd> <p>The content to add to the composition tree.</p> <p><em>content</em> is placed  between <em>parentVisual</em> and <em>childVisual</em> in the composition tree. </p> </dd></param>	
            <param name="device"><dd> <p>The device used to compose the content. </p> <p><strong>Note</strong>??<em>device</em> is created by the application.</p> </dd></param>	
            <param name="arentVisualRef"><dd> <p>The parent in the composition tree for the content being added.</p> <p><em>parentVisual</em> must also be a parent of <em>childVisual</em> in the composition tree.</p> </dd></param>	
            <param name="childVisual"><dd> <p>The child in the composition tree for the content being added.</p> <p><em>parentVisual</em> must also be a parent of <em>childVisual</em> in the composition tree.</p> </dd></param>	
            <returns>No documentation.</returns>	
            <!-- No matching elements were found for the following include tag --><include file="Documentation\CodeComments.xml" path="/comments/comment[@id='IDirectManipulationCompositor::AddContent']/*" />	
            <msdn-id>Hh768898</msdn-id>	
            <unmanaged>HRESULT IDirectManipulationCompositor::AddContent([In] IDirectManipulationContent* content,[In, Optional] IUnknown* device,[In, Optional] IUnknown* parentVisual,[In, Optional] IUnknown* childVisual)</unmanaged>	
            <unmanaged-short>IDirectManipulationCompositor::AddContent</unmanaged-short>	
        </member>
        <member name="M:SharpDX.DirectManipulation.CompositorNative.AddContent(SharpDX.DirectManipulation.Content,SharpDX.IUnknown,SharpDX.IUnknown,SharpDX.IUnknown)">
            <summary>
            <p>Associates content (owned by the caller) with the compositor, assigns a composition device to the content, and specifies the position of the content in the composition tree relative to other composition visuals. </p>
            </summary>
            <param name = "content"><dd> <p>The content to add to the composition tree.</p> <p><em>content</em> is placed  between <em>parentVisual</em> and <em>childVisual</em> in the composition tree. </p> </dd></param>
            <param name = "device"><dd> <p>The device used to compose the content. </p> <strong>Note</strong>??<em>device</em> is created by the application. ? </dd></param>
            <param name = "arentVisualRef"><dd> <p>The parent visuals in the composition tree of the content being added.</p> <p><em>parentVisual</em> must also be a parent of <em>childVisual</em> in the composition tree.</p> </dd></param>
            <param name = "childVisual"><dd> <p>The child visuals in the composition tree of the content being added.</p> <p><em>parentVisual</em> must also be a parent of <em>childVisual</em> in the composition tree.</p> </dd></param>
            <returns><p>If the method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>This method inserts a small visual tree (owned by the Direct Manipulation device) between the <em>parentVisual</em> and the <em>childVisual</em>. Transforms can then be applied to the inserted content.  
            </p><p>All content, regardless of type, must be added to the compositor. This can be primary content, obtained from the viewport by calling <strong>GetPrimaryContent</strong>, or secondary content, such as a panning indicator, created by calling <strong>CreateContent</strong>.
            </p><p>If the application uses a system-provided <strong><see cref = "T:SharpDX.DirectManipulation.Compositor"/></strong>:</p><ul> <li><em>device</em> must be an  <strong><see cref = "!:SharpDX.DirectComposition.Device"/></strong> object, and parent and child visuals must be <strong><see cref = "!:SharpDX.DirectComposition.Visual"/></strong> objects.</li> <li><em>device</em>, <em>parentVisual</em>, and <em>childVisual</em> cannot be <c>null</c>. </li> <li><em>device</em>, <em>parentVisual</em>, and <em>childVisual</em> objects are created and owned by the application.
            </li> <li>When content is added to the composition tree using this method, the new composition visuals are inserted between <em>parentVisual</em> and <em>childVisual</em>. The new visuals should not be destroyed until they are disassociated from the compositor with <strong>RemoveContent</strong>.</li> </ul><p>If the application uses a custom implementation of <strong><see cref = "T:SharpDX.DirectManipulation.Compositor"/></strong>:</p><ul> <li><em>device</em>, <em>parentVisual</em>, and <em>childVisual</em> must be a valid type for the compositor. They do not have to be <strong><see cref = "!:SharpDX.DirectComposition.Device"/></strong> or <strong><see cref = "!:SharpDX.DirectComposition.Visual"/></strong> objects.</li> <li><em>device</em>, <em>parentVisual</em>, and <em>childVisual</em> can be <c>null</c>, depending on the compositor. </li> </ul>
            </remarks>
            <doc-id>hh768898</doc-id>
            <unmanaged>HRESULT IDirectManipulationCompositor::AddContent([In] IDirectManipulationContent* content,[In, Optional] IUnknown* device,[In, Optional] IUnknown* parentVisual,[In, Optional] IUnknown* childVisual)</unmanaged>
            <unmanaged-short>IDirectManipulationCompositor::AddContent</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectManipulation.CompositorNative.RemoveContent(SharpDX.DirectManipulation.Content)">
            <summary>
            <p>Removes content from the compositor.</p>
            </summary>
            <param name = "content"><dd> <p>The content to remove from the composition tree.</p> </dd></param>
            <returns><p>If the method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>This method removes content added with <strong>AddContent</strong> and restores the original relationships between parent visuals and child visuals in the composition tree. In other words, <strong>RemoveContent</strong> undoes <strong>AddContent</strong>.</p>
            </remarks>
            <doc-id>hh768899</doc-id>
            <unmanaged>HRESULT IDirectManipulationCompositor::RemoveContent([In] IDirectManipulationContent* content)</unmanaged>
            <unmanaged-short>IDirectManipulationCompositor::RemoveContent</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectManipulation.CompositorNative.SetUpdateManager(SharpDX.DirectManipulation.UpdateManager)">
            <summary>
            <p> </p><p> Sets the update manager used to send compositor updates to Direct Manipulation. </p>
            </summary>
            <param name = "updateManager">No documentation.</param>
            <returns><p>If the method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>Retrieve <em>updateManager</em> by calling <strong>GetUpdateManager</strong>.</p><p>Call this method during Direct Manipulation initialization to connect the compositor to the <em>update manager</em>.</p>
            </remarks>
            <doc-id>hh768900</doc-id>
            <unmanaged>HRESULT IDirectManipulationCompositor::SetUpdateManager([In] IDirectManipulationUpdateManager* updateManager)</unmanaged>
            <unmanaged-short>IDirectManipulationCompositor::SetUpdateManager</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectManipulation.CompositorNative.Flush">
            <summary>
            <p>Commits all pending updates in the compositor to the system for rendering.</p>
            </summary>
            <returns><p>If the method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>This method enables Direct Manipulation to flush any pending changes to its visuals before a system event, such as a process suspension.</p>
            </remarks>
            <doc-id>jj647930</doc-id>
            <unmanaged>HRESULT IDirectManipulationCompositor::Flush()</unmanaged>
            <unmanaged-short>IDirectManipulationCompositor::Flush</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectManipulation.CompositorShadow.ToIntPtr(SharpDX.DirectManipulation.Compositor)">
            <summary>
            Return a pointer to the unmanaged version of this callback.
            </summary>
            <param name="callback">The callback.</param>
            <returns>A pointer to a shadow c++ callback</returns>
        </member>
        <member name="P:SharpDX.DirectManipulation.Content.ContentTransform">
            <summary>
            Retrieves the transform applied to the content.
            </summary>
        </member>
        <member name="P:SharpDX.DirectManipulation.Content.OutputTransform">
            <summary>
            Gets the final transform applied to the content.
            </summary>
        </member>
        <member name="M:SharpDX.DirectManipulation.Content.SyncContentTransform(SharpDX.Mathematics.Interop.RawMatrix3x2)">
            <summary>
            Modifies the content transform while maintaining the output transform.
            </summary>
            <param name="transform"></param>
        </member>
        <member name="M:SharpDX.DirectManipulation.Content.ToMatrix(System.Single[])">
            <summary>
            Converts the float array to the equivalend <see cref="T:SharpDX.Mathematics.Interop.RawMatrix3x2"/>.
            </summary>
            <param name="values">The values to convert.</param>
            <returns>The converted result.</returns>
        </member>
        <member name="M:SharpDX.DirectManipulation.Content.ToArray(SharpDX.Mathematics.Interop.RawMatrix3x2)">
            <summary>
            Converts the <see cref="T:SharpDX.Mathematics.Interop.RawMatrix3x2"/> to the equivalend float array.
            </summary>
            <param name="matrix">The matrix to convert.</param>
            <returns>The converted result array.</returns>
        </member>
        <member name="P:SharpDX.DirectManipulation.Content.ContentRect">
            <summary>
            <p>Retrieves or sets the bounding rectangle of the content, relative to the bounding rectangle of the viewport (if defined).</p>
            </summary>
            <remarks>
            <p>If the bounding rectangle  has not been set using <strong>SetContentRect</strong>, then <strong>UI_E_VALUE_NOT_SET</strong> is returned. However, the actual content rectangle is (-FLT_MAX, -FLT_MAX, FLT_MAX, FLT_MAX).</p>
            </remarks>
            <doc-id>hh768901</doc-id>
            <unmanaged>GetContentRect / SetContentRect</unmanaged>
            <unmanaged-short>GetContentRect</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectManipulation.Content.GetContentRect(SharpDX.Mathematics.Interop.RawRectangle@)">
            <summary>
            <p>Retrieves the bounding rectangle of the content, relative to the bounding rectangle of the viewport (if defined).</p>
            </summary>
            <param name = "contentSize"><dd> <p>The bounding rectangle of the content.</p> </dd></param>
            <returns><p>If the method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>If the bounding rectangle  has not been set using <strong>SetContentRect</strong>, then <strong>UI_E_VALUE_NOT_SET</strong> is returned. However, the actual content rectangle is (-FLT_MAX, -FLT_MAX, FLT_MAX, FLT_MAX).</p>
            </remarks>
            <doc-id>hh768901</doc-id>
            <unmanaged>HRESULT IDirectManipulationContent::GetContentRect([Out] RECT* contentSize)</unmanaged>
            <unmanaged-short>IDirectManipulationContent::GetContentRect</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectManipulation.Content.SetContentRect(SharpDX.Mathematics.Interop.RawRectangle)">
            <summary>
            <p>Specifies the bounding rectangle of the content, relative to its viewport.
            </p>
            </summary>
            <param name = "contentSize"><dd> <p>The bounding rectangle of the content.</p> </dd></param>
            <returns><p>If the method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>The default bounding rectangle is (-FLT_MAX, -FLT_MAX, FLT_MAX, FLT_MAX).</p>
            </remarks>
            <doc-id>hh768903</doc-id>
            <unmanaged>HRESULT IDirectManipulationContent::SetContentRect([In] const RECT* contentSize)</unmanaged>
            <unmanaged-short>IDirectManipulationContent::SetContentRect</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectManipulation.Content.GetViewport(System.Guid,System.IntPtr@)">
            <summary>
            <p>Retrieves the viewport that contains the content.</p>
            </summary>
            <param name = "riid"><dd> <p>A reference to the identifier of the interface to use.</p> </dd></param>
            <param name = "@object"><dd> <p>The viewport object.</p> </dd></param>
            <returns><p>If the method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>hh447011</doc-id>
            <unmanaged>HRESULT IDirectManipulationContent::GetViewport([In] const GUID&amp; riid,[Out] void** object)</unmanaged>
            <unmanaged-short>IDirectManipulationContent::GetViewport</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectManipulation.Content.GetTag(System.Guid,System.IntPtr@,System.Int32@)">
            <summary>
            <p> </p><p>Retrieves the tag object set on this content. </p>
            </summary>
            <param name = "riid"><dd> <p>A reference to the identifier of the interface to use. The tag object typically implements this interface.</p> </dd></param>
            <param name = "@object"><dd> <p>The tag object.</p> </dd></param>
            <param name = "id"><dd> <p>The ID portion of the tag.</p> </dd></param>
            <returns><p>If the method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p><strong>GetTag</strong> and <strong>SetTag</strong> are useful for associating an external COM object with the content without an external mapping between the two. They can also be used to pass information to callbacks generated for the content.</p><p><strong>GetTag</strong> queries the tag value for the specified interface and returns a reference to that interface.</p><p>A tag is a pairing of an integer ID (<em>id</em>) with a Component Object Model (COM) object (<em>object</em>). It can be used by an app to identify a motion.
            The parameters are optional, so that the method can return both parts of the tag, the identifier portion, or the tag object. </p>
            </remarks>
            <doc-id>hh447009</doc-id>
            <unmanaged>HRESULT IDirectManipulationContent::GetTag([In] const GUID&amp; riid,[Out, Optional] void** object,[Out, Optional] unsigned int* id)</unmanaged>
            <unmanaged-short>IDirectManipulationContent::GetTag</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectManipulation.Content.SetTag(SharpDX.IUnknown,System.Int32)">
            <summary>
            <p>Specifies the tag object for the content. </p>
            </summary>
            <param name = "@object"><dd> <p>The object portion of the tag.</p> </dd></param>
            <param name = "id"><dd> <p>The ID portion of the tag.</p> </dd></param>
            <returns><p>If the method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p> <strong>GetTag</strong> and <strong>SetTag</strong> are useful for associating an external COM object with the content without an external mapping between the two. They can also be used to pass information to callbacks generated for the content.</p><p>A tag is a pairing of an integer ID  (<em>id</em>) with a Component Object Model (COM) object (<em>object</em>). It can be used by an app to store and retrieve an arbitrary object associated with the content.</p><p>The <em>object</em> parameter is optional, so that the method can set just the identifier portion. </p>
            </remarks>
            <doc-id>hh447021</doc-id>
            <unmanaged>HRESULT IDirectManipulationContent::SetTag([In, Optional] IUnknown* object,[In] unsigned int id)</unmanaged>
            <unmanaged-short>IDirectManipulationContent::SetTag</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectManipulation.Content.GetOutputTransform(System.Single[],System.Int32)">
            <summary>
            <p>Gets the final transform applied to the content.</p>
            </summary>
            <param name = "matrix"><dd> <p>The transform matrix.</p> </dd></param>
            <param name = "pointCount"><dd> <p>The size of the transform matrix. This value is always 6, because a 3x2 matrix is used for all direct manipulation transforms.</p> </dd></param>
            <returns><p>If the method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>This transform might contain the other custom curves applied during manipulation and inertia.</p><p>This transform contains both the content transform and the sync transform set with <strong>SyncContentTransform</strong>. 
            </p><p></p><dl> <dt>The relationship between the three primary transforms is defined as:</dt> <dd> <code>Output transform = Pixel rounding (Sync transform * Content transform)</code> </dd> </dl>
            </remarks>
            <doc-id>hh447007</doc-id>
            <unmanaged>HRESULT IDirectManipulationContent::GetOutputTransform([Out, Buffer] float* matrix,[In] DWORD pointCount)</unmanaged>
            <unmanaged-short>IDirectManipulationContent::GetOutputTransform</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectManipulation.Content.GetContentTransform(System.Single[],System.Int32)">
            <summary>
            <p> Retrieves the transform applied to the content.</p>
            </summary>
            <param name = "matrix"><dd> <p>The transform matrix.</p> </dd></param>
            <param name = "pointCount"><dd> <p>The size of the transform matrix. This value is always 6, because a 3x2 matrix is used for all direct manipulation transforms.</p> </dd></param>
            <returns><p>If the method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>This transform contains the default overpan and bounce curves during manipulation and inertia.</p><p>This transform does not contain the sync transform set with <strong>SyncContentTransform</strong>.</p><p></p><dl> <dt>The relationship between the three primary transforms is defined as:</dt> <dd> <code>Output transform = Pixel rounding (Sync transform * Content transform)</code> </dd> </dl><p>When this method returns, the format of <em>matrix</em> is:</p><dl> <dd><em>matrix</em>[0]=ScaleX</dd> <dd><em>matrix</em>[1]=Unused</dd> <dd><em>matrix</em>[2]=Unused</dd> <dd><em>matrix</em>[3]=ScaleY
            </dd> <dd><em>matrix</em>[4]=TranslateX</dd> <dd><em>matrix</em>[5]=TranslateY</dd> </dl>
            </remarks>
            <doc-id>hh768902</doc-id>
            <unmanaged>HRESULT IDirectManipulationContent::GetContentTransform([Out, Buffer] float* matrix,[In] DWORD pointCount)</unmanaged>
            <unmanaged-short>IDirectManipulationContent::GetContentTransform</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectManipulation.Content.SyncContentTransform(System.Single[],System.Int32)">
            <summary>
            <p>Modifies the content transform while maintaining the output transform.</p>
            </summary>
            <param name = "matrix"><dd> <p>The transform matrix.</p> </dd></param>
            <param name = "pointCount"><dd> <p>The size of the transform matrix. This value is always 6, because a 3x2 matrix is used for all direct manipulation transforms.</p> </dd></param>
            <returns><p>If the method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>This method will fail if the viewport state is <strong>DIRECTMANIPULATION_RUNNING</strong>, <strong>DIRECTMANIPULATION_INERTIA</strong> or <strong>DIRECTMANIPULATION_SUSPENDED</strong>.</p><p>This method is useful when the application wants to apply transforms on top of the content transforms at the end of a manipulation, while preserving the visual output transform of the content.</p><p></p><dl> <dt>The relationship between the three primary transforms is defined as:</dt> <dd> <code>Output transform = Pixel rounding (Sync transform * Content transform)</code> </dd> </dl>
            </remarks>
            <doc-id>hh768904</doc-id>
            <unmanaged>HRESULT IDirectManipulationContent::SyncContentTransform([In, Buffer] const float* matrix,[In] DWORD pointCount)</unmanaged>
            <unmanaged-short>IDirectManipulationContent::SyncContentTransform</unmanaged-short>
        </member>
        <member name="P:SharpDX.DirectManipulation.DragDropBehavior.Configuration">
            <summary>
            <p>Sets the configuration of the drag-drop interaction for the viewport this behavior is attached to. </p>
            </summary>
            <remarks>
            <p>The configuration of the behavior can be set before or after it has been added to a viewport. If a configuration change is made while an interaction is occurring, the new configuration takes effect on the next interaction. ?
            </p><p> <strong>IDirectManipulationViewport::ActivateConfiguration</strong> should not be called prior to calling <strong>IDirectManipulationDragDropBehavior::SetConfiguration</strong>. This will result in  unexpected behavior.</p>
            </remarks>
            <doc-id>dn280391</doc-id>
            <unmanaged>SetConfiguration</unmanaged>
            <unmanaged-short>SetConfiguration</unmanaged-short>
        </member>
        <member name="P:SharpDX.DirectManipulation.DragDropBehavior.Status">
            <summary>
            <p>Gets the status of the drag-drop interaction for the viewport this behavior is attached to. </p>
            </summary>
            <remarks>
            <p>This method returns the drag-drop status at the time of the call and not at the time when the return value is read.</p>
            </remarks>
            <doc-id>dn280390</doc-id>
            <unmanaged>GetStatus</unmanaged>
            <unmanaged-short>GetStatus</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectManipulation.DragDropBehavior.SetConfiguration(SharpDX.DirectManipulation.DragDropConfiguration)">
            <summary>
            <p>Sets the configuration of the drag-drop interaction for the viewport this behavior is attached to. </p>
            </summary>
            <param name = "configuration"><dd> <p>Combination  of values from <strong><see cref = "T:SharpDX.DirectManipulation.DragDropConfiguration"/></strong>.</p> <p>For the configuration to be valid, <em>configuration</em> must contain exactly one of the following three values:</p><ul> <li><strong>DIRECTMANIPULATION_DRAG_DROP_CONFIGURATION_SELECT_ONLY</strong></li> <li><strong>DIRECTMANIPULATION_DRAG_DROP_CONFIGURATION_SELECT_DRAG</strong></li> <li><strong>DIRECTMANIPULATION_DRAG_DROP_CONFIGURATION_HOLD_DRAG</strong></li> </ul> <p>If <strong>DIRECTMANIPULATION_DRAG_DROP_CONFIGURATION_SELECT_ONLY</strong> or  <strong>DIRECTMANIPULATION_DRAG_DROP_CONFIGURATION_SELECT_DRAG</strong> is specified, one of <strong>DIRECTMANIPULATION_DRAG_DROP_CONFIGURATION_VERTICAL</strong> or <strong>DIRECTMANIPULATION_DRAG_DROP_CONFIGURATION_HORIZONTAL</strong> is required.</p> <p>If <strong>DIRECTMANIPULATION_DRAG_DROP_CONFIGURATION_HOLD_DRAG</strong> is specified, both <strong>DIRECTMANIPULATION_DRAG_DROP_CONFIGURATION_VERTICAL</strong> and <strong>DIRECTMANIPULATION_DRAG_DROP_CONFIGURATION_HORIZONTAL</strong> are required.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>The configuration of the behavior can be set before or after it has been added to a viewport. If a configuration change is made while an interaction is occurring, the new configuration takes effect on the next interaction. ?
            </p><p> <strong>IDirectManipulationViewport::ActivateConfiguration</strong> should not be called prior to calling <strong>IDirectManipulationDragDropBehavior::SetConfiguration</strong>. This will result in  unexpected behavior.</p>
            </remarks>
            <doc-id>dn280391</doc-id>
            <unmanaged>HRESULT IDirectManipulationDragDropBehavior::SetConfiguration([In] DIRECTMANIPULATION_DRAG_DROP_CONFIGURATION configuration)</unmanaged>
            <unmanaged-short>IDirectManipulationDragDropBehavior::SetConfiguration</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectManipulation.DragDropBehavior.GetStatus(SharpDX.DirectManipulation.DragDropStatus@)">
            <summary>
            <p>Gets the status of the drag-drop interaction for the viewport this behavior is attached to. </p>
            </summary>
            <param name = "status"><dd> <p>One of the values from <strong><see cref = "T:SharpDX.DirectManipulation.DragDropStatus"/></strong>.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>This method returns the drag-drop status at the time of the call and not at the time when the return value is read.</p>
            </remarks>
            <doc-id>dn280390</doc-id>
            <unmanaged>HRESULT IDirectManipulationDragDropBehavior::GetStatus([Out] DIRECTMANIPULATION_DRAG_DROP_STATUS* status)</unmanaged>
            <unmanaged-short>IDirectManipulationDragDropBehavior::GetStatus</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectManipulation.Manager.CreateContent``1(SharpDX.DirectManipulation.FrameInfoProvider,System.Guid)">
            <summary>
            The factory method that is used to create an instance of secondary content (such as a panning indicator) inside a viewport.
            </summary>
            <typeparam name="T">The type of the COM object to create.</typeparam>
            <param name="frameInfo">The frame info provider for the secondary content. This should match the frame info provider used to create the viewport.</param>
            <param name="contentClassId">Class identifier (CLSID) of the secondary content. This ID specifies the content type.</param>
            <returns></returns>
        </member>
        <member name="F:SharpDX.DirectManipulation.Manager.VerticalIndicatorContent">
            <summary>Constant VerticalIndicatorContent</summary>
            <unmanaged>CLSID_VerticalIndicatorContent</unmanaged>
        </member>
        <member name="F:SharpDX.DirectManipulation.Manager.HorizontalIndicatorContent">
            <summary>Constant HorizontalIndicatorContent</summary>
            <unmanaged>CLSID_HorizontalIndicatorContent</unmanaged>
        </member>
        <member name="F:SharpDX.DirectManipulation.Manager.VirtualViewportContent">
            <summary>Constant VirtualViewportContent</summary>
            <unmanaged>CLSID_VirtualViewportContent</unmanaged>
        </member>
        <member name="M:SharpDX.DirectManipulation.Manager.Activate(System.IntPtr)">
            <summary>
            <p>Activates Direct Manipulation for processing input and  handling callbacks on the specified window. </p>
            </summary>
            <param name = "window">No documentation.</param>
            <returns><p>If the method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>The manipulation manager is deactivated, by default. The manager does not receive or respond to input and callbacks until <strong>Activate</strong> is called for the window.  </p><p>Calls to <strong>Activate</strong> and <strong>Deactivate</strong> are reference counted.
            </p>
            </remarks>
            <doc-id>hh447029</doc-id>
            <unmanaged>HRESULT IDirectManipulationManager::Activate([In] HWND window)</unmanaged>
            <unmanaged-short>IDirectManipulationManager::Activate</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectManipulation.Manager.Deactivate(System.IntPtr)">
            <summary>
            <p>Deactivates Direct Manipulation for processing input and  handling callbacks on the specified window. </p>
            </summary>
            <param name = "window">No documentation.</param>
            <returns><p>If the method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>The manipulation manager is deactivated by default. The manager does not receive or respond to input until <strong>Activate</strong> is called. The manipulation manager should be deactivated when the app does not receive or respond to input. For example, when the app is minimized.</p><p>Calls to <strong>Activate</strong> and <strong>Deactivate</strong> are reference counted.
            </p>
            </remarks>
            <doc-id>hh447036</doc-id>
            <unmanaged>HRESULT IDirectManipulationManager::Deactivate([In] HWND window)</unmanaged>
            <unmanaged-short>IDirectManipulationManager::Deactivate</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectManipulation.Manager.RegisterHitTestTarget(System.IntPtr,System.IntPtr,SharpDX.DirectManipulation.HitTestType)">
            <summary>
            <p>Registers a dedicated thread for hit testing.</p>
            </summary>
            <param name = "window"><dd> <p>The handle of the main app window (typically created from the UI thread).</p> </dd></param>
            <param name = "hitTestWindow"><dd> <p>The handle of the window in which hit testing is registered (should be created from the hit testing thread). Pass in nullptr to unregister a previously registered hit-test target.</p> </dd></param>
            <param name = "type"><dd> <p>One of the values from <strong><see cref = "T:SharpDX.DirectManipulation.HitTestType"/></strong>. Specifies whether the UI window or the hit testing window (or both) receives the hit testing <strong>WM_POINTERDOWN</strong> message , and in what order.</p> </dd></param>
            <returns><p>If the method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>Hit testing is typically performed on the application UI thread. The application receives a <strong>WM_POINTERDOWN</strong> message on which hit-testing is performed. If a manipulation is required, <strong>SetContact</strong> is called on one or more viewports. An application can use the <strong>RegisterHitTestTarget</strong> method to delegate this hit-testing responsibility to a separate hit-testing thread.
            </p><p>Once a dedicated hit-test target is successfully registered, <strong>WM_POINTERDOWN</strong> messages are processed on the hit-testing thread. If a manipulation, such as pan or zoom, is required, <strong>SetContact</strong> is called from this thread.
            </p><p>If <strong>SetContact</strong> is not called from the hit-testing thread, <strong>WM_POINTERDOWN</strong> messages may be processed on the UI thread, depending on the <strong><see cref = "T:SharpDX.DirectManipulation.HitTestType"/></strong> specified during registration.
            </p><p>If <strong>SetContact</strong> is not called by either the hit-test thread or the UI thread, Direct Manipulation ignores the input which is then handled on the UI thread.
            </p>
            </remarks>
            <doc-id>hh768905</doc-id>
            <unmanaged>HRESULT IDirectManipulationManager::RegisterHitTestTarget([In] HWND window,[In, Optional] HWND hitTestWindow,[In] DIRECTMANIPULATION_HITTEST_TYPE type)</unmanaged>
            <unmanaged-short>IDirectManipulationManager::RegisterHitTestTarget</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectManipulation.Manager.ProcessInput(SharpDX.Win32.NativeMessage@,SharpDX.Mathematics.Interop.RawBool@)">
            <summary>
            <p>Passes keyboard and mouse messages to the manipulation manager on the app's UI thread.</p>
            </summary>
            <param name = "message"><dd> <p>The input message to process.</p> </dd></param>
            <param name = "handled"><dd> <p><strong>TRUE</strong> if no further processing should be done with this message; otherwise, <strong><see cref = "F:SharpDX.Result.False"/></strong>.</p> </dd></param>
            <returns><p>If the method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>Call this method for mouse and keyboard input.</p>
            </remarks>
            <doc-id>hh447040</doc-id>
            <unmanaged>HRESULT IDirectManipulationManager::ProcessInput([In] const MSG* message,[Out] BOOL* handled)</unmanaged>
            <unmanaged-short>IDirectManipulationManager::ProcessInput</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectManipulation.Manager.GetUpdateManager(System.Guid,System.IntPtr@)">
            <summary>
            <p>Gets a reference to an <strong><see cref = "T:SharpDX.DirectManipulation.UpdateManager"/></strong> object that receives compositor updates. </p>
            </summary>
            <param name = "riid">No documentation.</param>
            <param name = "@object">No documentation.</param>
            <returns><p>If the method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>For the compositor to respond to update events from Direct Manipulation, you must associate <strong><see cref = "T:SharpDX.DirectManipulation.UpdateManager"/></strong> to an <strong><see cref = "T:SharpDX.DirectManipulation.Compositor"/></strong> object during initialization. Use  <strong>GetUpdateManager</strong> to obtain a reference to a <strong><see cref = "T:SharpDX.DirectManipulation.UpdateManager"/></strong> object. Pass this reference to the compositor using the <strong>SetUpdateManager</strong> method.</p>
            </remarks>
            <doc-id>hh447038</doc-id>
            <unmanaged>HRESULT IDirectManipulationManager::GetUpdateManager([In] const GUID&amp; riid,[Out] void** object)</unmanaged>
            <unmanaged-short>IDirectManipulationManager::GetUpdateManager</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectManipulation.Manager.CreateViewport(SharpDX.DirectManipulation.FrameInfoProvider,System.IntPtr,System.Guid,System.IntPtr@)">
            <summary>
            <p>The factory method that is used to create a new <strong><see cref = "T:SharpDX.DirectManipulation.Viewport"/></strong> object.</p><p>The viewport manages the interaction state and mapping of input to output actions.</p>
            </summary>
            <param name = "frameInfo">No documentation.</param>
            <param name = "window">No documentation.</param>
            <param name = "riid">No documentation.</param>
            <param name = "@object">No documentation.</param>
            <returns><p>If the method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>hh447034</doc-id>
            <unmanaged>HRESULT IDirectManipulationManager::CreateViewport([In, Optional] IDirectManipulationFrameInfoProvider* frameInfo,[In] HWND window,[In] const GUID&amp; riid,[Out] void** object)</unmanaged>
            <unmanaged-short>IDirectManipulationManager::CreateViewport</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectManipulation.Manager.CreateContent(SharpDX.DirectManipulation.FrameInfoProvider,System.Guid,System.Guid,System.IntPtr@)">
            <summary>
            <p>The factory method that is used to create an instance of secondary content (such as a panning indicator) inside a viewport.</p>
            </summary>
            <param name = "frameInfo"><dd> <p>The frame info provider for the secondary content. This should match the frame info provider used to create the viewport.</p> </dd></param>
            <param name = "clsid"><dd> <p>Class identifier (CLSID) of the secondary content. This ID specifies the content type.</p> </dd></param>
            <param name = "riid"><dd> <p>IID of the interface.</p> </dd></param>
            <param name = "@object"><dd> <p>The secondary content object that implements the specified interface.</p> </dd></param>
            <returns><p>If the method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>Primary content is automatically created at the same time as the viewport and has a one-to-one relationship to a viewport. Therefore, it is not possible to create, add, or remove primary content.</p><p>Secondary content is created independently from the viewport. There is no limit to how much secondary content can be added or removed from a viewport. All secondary content transforms are derived from those supported by the primary content with specific rules applied based on the intended purpose of the element (identified by its Class identifier (CLSID)).</p>
            </remarks>
            <doc-id>hh447030</doc-id>
            <unmanaged>HRESULT IDirectManipulationManager::CreateContent([In, Optional] IDirectManipulationFrameInfoProvider* frameInfo,[In] const GUID&amp; clsid,[In] const GUID&amp; riid,[Out] void** object)</unmanaged>
            <unmanaged-short>IDirectManipulationManager::CreateContent</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectManipulation.Manager2.CreateBehavior``1(System.Guid)">
            <summary>
            Factory method to create a behavior.
            </summary>
            <typeparam name="T">The type of the COM object to create.</typeparam>
            <param name="classId">CLSID of the behavior. The CLSID specifies the type of behavior.</param>
            <returns></returns>
        </member>
        <member name="F:SharpDX.DirectManipulation.Manager2.DragDropConfigurationBehavior">
            <summary>Constant DragDropConfigurationBehavior</summary>
            <unmanaged>CLSID_DragDropConfigurationBehavior</unmanaged>
        </member>
        <member name="F:SharpDX.DirectManipulation.Manager2.AutoScrollBehavior">
            <summary>Constant AutoScrollBehavior</summary>
            <unmanaged>CLSID_AutoScrollBehavior</unmanaged>
        </member>
        <member name="M:SharpDX.DirectManipulation.Manager2.CreateBehavior(System.Guid,System.Guid,System.IntPtr@)">
            <summary>
            <p>Factory method to create a behavior.</p>
            </summary>
            <param name = "clsid"><dd> <p>CLSID of the behavior. The CLSID specifies the type of behavior.</p> </dd></param>
            <param name = "riid"><dd> <p>The IID of the behavior interface to create.</p> </dd></param>
            <param name = "@object"><dd> <p>The new behavior object that implements the specified interface.</p> </dd></param>
            <returns><p>If the method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dn280397</doc-id>
            <unmanaged>HRESULT IDirectManipulationManager2::CreateBehavior([In] const GUID&amp; clsid,[In] const GUID&amp; riid,[Out] void** object)</unmanaged>
            <unmanaged-short>IDirectManipulationManager2::CreateBehavior</unmanaged-short>
        </member>
        <member name="P:SharpDX.DirectManipulation.Viewport.Contact">
            <summary>
            <p>Specifies an  association between a contact and the viewport.</p>
            </summary>
            <remarks>
            <p>Call this method when a <strong>WM_POINTERDOWN</strong> message is received. Upon receiving a <strong>WM_POINTERDOWN</strong>, the application can use the coordinates of the input to hit-test and determine the viewports to which the contact is associated.
            </p><p> <strong>DeferContact</strong> must be called before <strong>SetContact</strong>.</p><p>After initialization, Direct Manipulation is not aware of viewport z-order or parent-child relations between viewports. The order of <strong>SetContact</strong> calls defines the viewport tree. To establish the correct viewport hierarchy, <strong>SetContact</strong> should be called first on the child-most viewport, followed by the parent, grand-parent, and so on. 
            </p><p>Use <strong>GET_POINTERID_WPARAM</strong> to get the reference identifier from a reference message. The contact is removed automatically when <strong>WM_POINTERUP</strong> is received.
            </p><p>If a contact is associated with one or more viewports using the <strong>SetContact</strong> method, Direct Manipulation will examine further input from that contact and attempt to identify an appropriate manipulation based on the configuration of the associated viewports. If a manipulation is recognized, the application will then receive a <strong>WM_POINTERCAPTURECHANGED</strong> message for this contact. In this context, the <strong>WM_POINTERCAPTURECHANGED</strong> message indicates that Direct Manipulation has captured the contact and the application will not receive input from this contact that is consumed for this manipulation.</p>
            </remarks>
            <doc-id>hh768921</doc-id>
            <unmanaged>SetContact</unmanaged>
            <unmanaged-short>SetContact</unmanaged-short>
        </member>
        <member name="P:SharpDX.DirectManipulation.Viewport.Status">
            <summary>
            <p>Gets the state of the viewport.</p>
            </summary>
            <remarks>
            <p>This method returns the viewport state at the time of the call and not at the time when the return value is read.</p><p>This method will fail if called after <strong>Abandon</strong>.</p>
            </remarks>
            <doc-id>hh447167</doc-id>
            <unmanaged>GetStatus</unmanaged>
            <unmanaged-short>GetStatus</unmanaged-short>
        </member>
        <member name="P:SharpDX.DirectManipulation.Viewport.ViewportRect">
            <summary>
            <p>Retrieves or sets the rectangle for the viewport relative to the origin of the viewport coordinate system specified by <strong>SetViewportRect</strong>.</p>
            </summary>
            <doc-id>hh768918</doc-id>
            <unmanaged>GetViewportRect / SetViewportRect</unmanaged>
            <unmanaged-short>GetViewportRect</unmanaged-short>
        </member>
        <member name="P:SharpDX.DirectManipulation.Viewport.ViewportOptions">
            <summary>
            <p>Sets how the viewport handles input and output.</p><p>Calling this method overrides all  settings previously specified with <strong>SetUpdateMode</strong> or <strong>SetInputMode</strong>.</p>
            </summary>
            <remarks>
            <p>Calling this method with <strong>DIRECTMANIPULATION_INPUT_MODE_MANUAL</strong> set is similar to calling <strong>SetViewportOptions(DIRECTMANIPULATION_VIEWPORT_OPTIONS_INPUT)</strong>.</p>
            </remarks>
            <doc-id>jj647932</doc-id>
            <unmanaged>SetViewportOptions</unmanaged>
            <unmanaged-short>SetViewportOptions</unmanaged-short>
        </member>
        <member name="P:SharpDX.DirectManipulation.Viewport.ManualGesture">
            <summary>
            <p>Sets which gestures are ignored by Direct Manipulation. </p>
            </summary>
            <remarks>
            <p>Use this method to specify which gestures the application processes on the UI thread. If a gesture is recognized, it will be passed to the application for processing and ignored by Direct Manipulation.</p>
            </remarks>
            <doc-id>jj654881</doc-id>
            <unmanaged>SetManualGesture</unmanaged>
            <unmanaged-short>SetManualGesture</unmanaged-short>
        </member>
        <member name="P:SharpDX.DirectManipulation.Viewport.Chaining">
            <summary>
            <p>Specifies the motion types supported in a viewport that can be chained to a parent viewport.</p>
            </summary>
            <doc-id>hh447174</doc-id>
            <unmanaged>SetChaining</unmanaged>
            <unmanaged-short>SetChaining</unmanaged-short>
        </member>
        <member name="P:SharpDX.DirectManipulation.Viewport.InputMode">
            <summary>
            <p>Specifies if input is visible to the UI thread.</p>
            </summary>
            <remarks>
            <p>DIRECTMANIPULATION_INPUT_MODE_AUTOMATIC is the default mode for Direct Manipulation. </p><p> Direct Manipulation consumes all the input that drives the manipulation and the application receives WM_POINTERCAPTURECHANGED messages. 
            </p><p>In some situations an application may want to receive input that is driving a manipulation. Set DIRECTMANIPULATION_INPUT_MODE_MANUAL in this case. The application will receive all input messages, even input used by Direct Manipulation to drive a manipulation. </p><strong>Note</strong>??The application will not receive WM_POINTERCAPTURECHANGED messages.?<p>Calling this method with <strong>DIRECTMANIPULATION_INPUT_MODE_MANUAL</strong> set is similar to calling <strong>SetViewportOptions(DIRECTMANIPULATION_VIEWPORT_OPTIONS_INPUT)</strong>. However, calling <strong>SetViewportOptions</strong> also overrides all other settings.</p>
            </remarks>
            <doc-id>hh447176</doc-id>
            <unmanaged>SetInputMode</unmanaged>
            <unmanaged-short>SetInputMode</unmanaged-short>
        </member>
        <member name="P:SharpDX.DirectManipulation.Viewport.UpdateMode">
            <summary>
            <p> Specifies whether a viewport updates content manually instead of during an input event.</p>
            </summary>
            <remarks>
            <p>DIRECTMANIPULATION_INPUT_MODE_AUTOMATIC is the default mode for Direct Manipulation. In this mode, visual updates are pushed to compositor driven by input. This is the expected mode of operation if the application is using system-provided implementation of <strong><see cref = "T:SharpDX.DirectManipulation.Compositor"/></strong>.
            </p><p>If the application provides its own implementation of <strong><see cref = "T:SharpDX.DirectManipulation.Compositor"/></strong>, it should switch viewport update mode to manual by setting DIRECTMANIPULATION_INPUT_MODE_MANUAL. When in manual mode, the compositor pulls visual updates whenever it calls <strong>Update</strong> on Direct Manipulation.
            </p><p>Calling this method with <strong>DIRECTMANIPULATION_INPUT_MODE_MANUAL</strong> set is similar to calling <strong>SetViewportOptions(DIRECTMANIPULATION_VIEWPORT_OPTIONS_INPUT)</strong>. However, calling <strong>SetViewportOptions</strong> also overrides all other settings.</p>
            </remarks>
            <doc-id>hh768922</doc-id>
            <unmanaged>SetUpdateMode</unmanaged>
            <unmanaged-short>SetUpdateMode</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectManipulation.Viewport.Enable">
            <summary>
            <p>Starts or resumes input processing by the viewport.</p>
            </summary>
            <returns><p>If the method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>, or <strong>S_FALSE</strong> if there is no work to do (for example, the viewport is already enabled). Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>This method directs a viewport to attempt to respond to input.</p><p>Call this method if the <strong>AUTODISABLE</strong> option is set. </p>
            </remarks>
            <doc-id>hh447163</doc-id>
            <unmanaged>HRESULT IDirectManipulationViewport::Enable()</unmanaged>
            <unmanaged-short>IDirectManipulationViewport::Enable</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectManipulation.Viewport.Disable">
            <summary>
            <p>Stops input processing by the viewport.</p>
            </summary>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>When a viewport is disabled, it immediately stops all transforms and moves the content to the final location. </p><p>Call this method when you want to modify multiple attributes atomically. This method can be called at any time. </p><p>The viewport will not resume processing input until <strong>Enable</strong> is called. </p>
            </remarks>
            <doc-id>hh447162</doc-id>
            <unmanaged>HRESULT IDirectManipulationViewport::Disable()</unmanaged>
            <unmanaged-short>IDirectManipulationViewport::Disable</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectManipulation.Viewport.SetContact(System.Int32)">
            <summary>
            <p>Specifies an  association between a contact and the viewport.</p>
            </summary>
            <param name = "pointerId"><dd> <p>The ID of the reference.</p> </dd></param>
            <returns><p>If the method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>Call this method when a <strong>WM_POINTERDOWN</strong> message is received. Upon receiving a <strong>WM_POINTERDOWN</strong>, the application can use the coordinates of the input to hit-test and determine the viewports to which the contact is associated.
            </p><p> <strong>DeferContact</strong> must be called before <strong>SetContact</strong>.</p><p>After initialization, Direct Manipulation is not aware of viewport z-order or parent-child relations between viewports. The order of <strong>SetContact</strong> calls defines the viewport tree. To establish the correct viewport hierarchy, <strong>SetContact</strong> should be called first on the child-most viewport, followed by the parent, grand-parent, and so on. 
            </p><p>Use <strong>GET_POINTERID_WPARAM</strong> to get the reference identifier from a reference message. The contact is removed automatically when <strong>WM_POINTERUP</strong> is received.
            </p><p>If a contact is associated with one or more viewports using the <strong>SetContact</strong> method, Direct Manipulation will examine further input from that contact and attempt to identify an appropriate manipulation based on the configuration of the associated viewports. If a manipulation is recognized, the application will then receive a <strong>WM_POINTERCAPTURECHANGED</strong> message for this contact. In this context, the <strong>WM_POINTERCAPTURECHANGED</strong> message indicates that Direct Manipulation has captured the contact and the application will not receive input from this contact that is consumed for this manipulation.</p>
            </remarks>
            <doc-id>hh768921</doc-id>
            <unmanaged>HRESULT IDirectManipulationViewport::SetContact([In] unsigned int pointerId)</unmanaged>
            <unmanaged-short>IDirectManipulationViewport::SetContact</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectManipulation.Viewport.ReleaseContact(System.Int32)">
            <summary>
            <p>Removes a contact that is associated with a viewport.</p>
            </summary>
            <param name = "pointerId"><dd> <p>The ID of the reference.</p> </dd></param>
            <returns><p>If the method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>This method releases a contact from a specific Direct Manipulation viewport (equivalent to the user removing a touch point). </p><p>The viewport state is not affected unless the last remaining contact on the viewport is removed, in which case the viewport will transition to inertia, if supported. </p>
            </remarks>
            <doc-id>hh768920</doc-id>
            <unmanaged>HRESULT IDirectManipulationViewport::ReleaseContact([In] unsigned int pointerId)</unmanaged>
            <unmanaged-short>IDirectManipulationViewport::ReleaseContact</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectManipulation.Viewport.ReleaseAllContacts">
            <summary>
            <p>Removes all contacts that are associated with the viewport. Inertia is started if the viewport supports inertia.</p>
            </summary>
            <returns><p>If the method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>This is equivalent to calling <strong>ReleaseContact</strong> on every contact associated with the viewport. The outcome is equivalent to the user removing all touch points from the viewport. </p><p>If supported, inertia will be started after calling this method.</p>
            </remarks>
            <doc-id>hh768919</doc-id>
            <unmanaged>HRESULT IDirectManipulationViewport::ReleaseAllContacts()</unmanaged>
            <unmanaged-short>IDirectManipulationViewport::ReleaseAllContacts</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectManipulation.Viewport.GetStatus(SharpDX.DirectManipulation.Status@)">
            <summary>
            <p>Gets the state of the viewport.</p>
            </summary>
            <param name = "status"><dd> <p>One of the values from <strong><see cref = "T:SharpDX.DirectManipulation.Status"/></strong>.</p> </dd></param>
            <returns><p>If the method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>This method returns the viewport state at the time of the call and not at the time when the return value is read.</p><p>This method will fail if called after <strong>Abandon</strong>.</p>
            </remarks>
            <doc-id>hh447167</doc-id>
            <unmanaged>HRESULT IDirectManipulationViewport::GetStatus([Out] DIRECTMANIPULATION_STATUS* status)</unmanaged>
            <unmanaged-short>IDirectManipulationViewport::GetStatus</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectManipulation.Viewport.GetTag(System.Guid,System.IntPtr@,System.Int32@)">
            <summary>
            <p>Gets the tag value of a viewport.</p>
            </summary>
            <param name = "riid"><dd> <p>IID to the interface.</p> </dd></param>
            <param name = "@object"><dd> <p>The object portion of the tag.</p> </dd></param>
            <param name = "id"><dd> <p>The identifier portion of the tag.</p> </dd></param>
            <returns><p>If the method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>A tag is a pairing of an integer ID with a Component Object Model (COM) object. It can be used by an app to identify the viewport.</p><p> The out parameters are optional, so the method can return an ID, the viewport object, or both.
            </p>
            </remarks>
            <doc-id>hh447168</doc-id>
            <unmanaged>HRESULT IDirectManipulationViewport::GetTag([In] const GUID&amp; riid,[Out, Optional] void** object,[Out, Optional] unsigned int* id)</unmanaged>
            <unmanaged-short>IDirectManipulationViewport::GetTag</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectManipulation.Viewport.SetTag(SharpDX.IUnknown,System.Int32)">
            <summary>
            <p>Sets a viewport tag.</p>
            </summary>
            <param name = "@object"><dd> <p>The object portion of the tag.</p> </dd></param>
            <param name = "id"><dd> <p>The ID portion of the tag.</p> </dd></param>
            <returns><p>If the method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>A tag is a pairing of an integer ID with a Component Object Model (COM) object. It can be used by an app to identify the viewport.</p><p> The object parameter is optional, so that the method can set just an ID.
            </p>
            </remarks>
            <doc-id>hh447180</doc-id>
            <unmanaged>HRESULT IDirectManipulationViewport::SetTag([In, Optional] IUnknown* object,[In] unsigned int id)</unmanaged>
            <unmanaged-short>IDirectManipulationViewport::SetTag</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectManipulation.Viewport.GetViewportRect(SharpDX.Mathematics.Interop.RawRectangle@)">
            <summary>
            <p>Retrieves the rectangle for the viewport relative to the origin of the viewport coordinate system specified by <strong>SetViewportRect</strong>.</p>
            </summary>
            <param name = "viewport">No documentation.</param>
            <returns><p>If the method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>hh768918</doc-id>
            <unmanaged>HRESULT IDirectManipulationViewport::GetViewportRect([Out] RECT* viewport)</unmanaged>
            <unmanaged-short>IDirectManipulationViewport::GetViewportRect</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectManipulation.Viewport.SetViewportRect(SharpDX.Mathematics.Interop.RawRectangle)">
            <summary>
            <p> Sets the bounding rectangle for the viewport, relative to the origin of the viewport coordinate system.</p>
            </summary>
            <param name = "viewport"><dd> <p>The bounding rectangle.</p> </dd></param>
            <returns><p>If the method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>The viewport rectangle specifies the region of content that is visible to the user. In conjunction with the primary content rectangle, the viewport rectangle is used to determine chaining behaviors.</p>
            </remarks>
            <doc-id>hh768923</doc-id>
            <unmanaged>HRESULT IDirectManipulationViewport::SetViewportRect([In] const RECT* viewport)</unmanaged>
            <unmanaged-short>IDirectManipulationViewport::SetViewportRect</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectManipulation.Viewport.ZoomToRect(System.Single,System.Single,System.Single,System.Single,SharpDX.Mathematics.Interop.RawBool)">
            <summary>
            <p>Moves the viewport to a specific area of the primary content and specifies whether to animate the transition.</p>
            </summary>
            <param name = "left"><dd> <p>The leftmost coordinate of the rectangle in the primary content coordinate space.</p> </dd></param>
            <param name = "top"><dd> <p>The topmost coordinate of the rectangle in the primary content coordinate space.</p> </dd></param>
            <param name = "right"><dd> <p>The rightmost coordinate of the rectangle in the primary content coordinate space.</p> </dd></param>
            <param name = "bottom"><dd> <p>The bottommost coordinate of the rectangle in the primary content coordinate space.</p> </dd></param>
            <param name = "animate"><dd> <p>Specifies whether to animate the zoom behavior.</p> </dd></param>
            <returns><p>If the method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>hh447184</doc-id>
            <unmanaged>HRESULT IDirectManipulationViewport::ZoomToRect([In] const float left,[In] const float top,[In] const float right,[In] const float bottom,[In] BOOL animate)</unmanaged>
            <unmanaged-short>IDirectManipulationViewport::ZoomToRect</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectManipulation.Viewport.SetViewportTransform(System.Single[],System.Int32)">
            <summary>
            <p>Specifies the transform from the viewport coordinate system to the window client coordinate system. </p>
            </summary>
            <param name = "matrix"><dd> <p>The transform matrix, in row-wise order: _11, _12, _21, _22, _31, _32.</p> </dd></param>
            <param name = "pointCount"><dd> <p>The size of the transform matrix. This value is always 6, because a 3x2 matrix is used for all direct manipulation transforms.</p> </dd></param>
            <returns><p>If the method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>Call this function to specify the viewport position, scaling and orientation on the screen. Viewport position, scaling, orientation and size are uniquely determined by the viewport transform and the viewport rectangle. The application can specify the viewport transform using this method, and the viewport rectangle using <strong>SetViewportRect</strong>. 
            </p><p>The viewport rectangle (the rectangular area inside the content that is visible to the user) is specified in viewport coordinates. If the viewport rectangle top-left point is (0,0), the viewport rectangle is positioned exactly at the viewport coordinate system origin. Viewports offset from the viewport coordinate system origin can be specified in two ways:</p><ul> <li>Through the viewport rectangle top-left point</li> <li>Through the viewport transform translation component (_31, _32)</li> </ul><p>The viewport transform converts from the viewport coordinate system to the window client coordinate system. Direct Manipulation ignores the window RTL property, so the client area origin is always the top-left point. 
            The transforms are applied in the following order:
            </p><ol> <li>Viewport rectangle offset</li> <li>Viewport transform (from viewport to client coordinate system)</li> <li>Client to screen mapping (from client to screen coordinate system)
            </li> </ol>
            </remarks>
            <doc-id>hh768924</doc-id>
            <unmanaged>HRESULT IDirectManipulationViewport::SetViewportTransform([In, Buffer] const float* matrix,[In] DWORD pointCount)</unmanaged>
            <unmanaged-short>IDirectManipulationViewport::SetViewportTransform</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectManipulation.Viewport.SyncDisplayTransform(System.Single[],System.Int32)">
            <summary>
            <p>Specifies a display transform for the viewport, and synchronizes the output transform with the new value of the display transform.</p>
            </summary>
            <param name = "matrix"><dd> <p>The transform matrix, in row-wise order: _11, _12, _21, _22, _31, _32.</p> </dd></param>
            <param name = "pointCount"><dd> <p>The size of the transform matrix. This value is always 6, because a 3x2 matrix is used for all direct manipulation transforms.</p> </dd></param>
            <returns><p>If the method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>If the application performs special output processing of the content outside of the compositor (content not fully captured in the viewport transform), it should call this method to specify the display transform for the special processing.
            </p><p>The display transform affects how manipulation updates are applied to the output transform. For example, if the display transform is set to scale 3x, panning will move the content 3x the original distance. 
            </p><p>When a display transform is changed using this method, the output transform will be synchronized to the new value of the display transform.
            </p><p>This method cannot be called if the viewport status is <strong>DIRECTMANIPULATION_RUNNING</strong> or <strong>DIRECTMANIPULATION_INERTIA</strong>.
            </p>
            </remarks>
            <doc-id>hh768926</doc-id>
            <unmanaged>HRESULT IDirectManipulationViewport::SyncDisplayTransform([In, Buffer] const float* matrix,[In] DWORD pointCount)</unmanaged>
            <unmanaged-short>IDirectManipulationViewport::SyncDisplayTransform</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectManipulation.Viewport.GetPrimaryContent(System.Guid,System.IntPtr@)">
            <summary>
            <p>Gets the primary content of a viewport that implements <strong><see cref = "T:SharpDX.DirectManipulation.Content"/></strong> and <strong><see cref = "T:SharpDX.DirectManipulation.PrimaryContent"/></strong>. </p><p>Primary content is an element that gets transformed (e.g. moved, scaled, rotated) in response to a user interaction. Primary content is created at the same time as the viewport and cannot be added or removed.</p>
            </summary>
            <param name = "riid">No documentation.</param>
            <param name = "@object">No documentation.</param>
            <returns><p>If the method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p> This method gets the content of the viewport that implements <strong><see cref = "T:SharpDX.DirectManipulation.Content"/></strong> and <strong><see cref = "T:SharpDX.DirectManipulation.PrimaryContent"/></strong>.
            </p>
            </remarks>
            <doc-id>hh447166</doc-id>
            <unmanaged>HRESULT IDirectManipulationViewport::GetPrimaryContent([In] const GUID&amp; riid,[Out] void** object)</unmanaged>
            <unmanaged-short>IDirectManipulationViewport::GetPrimaryContent</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectManipulation.Viewport.AddContent(SharpDX.DirectManipulation.Content)">
            <summary>
            <p>Adds secondary content, such as a panning indicator, to a viewport.</p>
            </summary>
            <param name = "content"><dd> <p>The content to add to the viewport.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>Secondary content is created by calling <strong>CreateContent</strong>. Once added, the secondary content will move relative to the primary content in response to a manipulation. Its motion is determined by rules associated with each type of secondary content.</p>
            </remarks>
            <doc-id>hh447158</doc-id>
            <unmanaged>HRESULT IDirectManipulationViewport::AddContent([In] IDirectManipulationContent* content)</unmanaged>
            <unmanaged-short>IDirectManipulationViewport::AddContent</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectManipulation.Viewport.RemoveContent(SharpDX.DirectManipulation.Content)">
            <summary>
            <p>Removes secondary content from a viewport.</p>
            </summary>
            <param name = "content"><dd> <p>The content object to remove.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>Secondary content can be removed from the viewport at any time.</p>
            </remarks>
            <doc-id>hh447171</doc-id>
            <unmanaged>HRESULT IDirectManipulationViewport::RemoveContent([In] IDirectManipulationContent* content)</unmanaged>
            <unmanaged-short>IDirectManipulationViewport::RemoveContent</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectManipulation.Viewport.SetViewportOptions(SharpDX.DirectManipulation.ViewportOptions)">
            <summary>
            <p>Sets how the viewport handles input and output.</p><p>Calling this method overrides all  settings previously specified with <strong>SetUpdateMode</strong> or <strong>SetInputMode</strong>.</p>
            </summary>
            <param name = "options">No documentation.</param>
            <returns><p>If the method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>Calling this method with <strong>DIRECTMANIPULATION_INPUT_MODE_MANUAL</strong> set is similar to calling <strong>SetViewportOptions(DIRECTMANIPULATION_VIEWPORT_OPTIONS_INPUT)</strong>.</p>
            </remarks>
            <doc-id>jj647932</doc-id>
            <unmanaged>HRESULT IDirectManipulationViewport::SetViewportOptions([In] DIRECTMANIPULATION_VIEWPORT_OPTIONS options)</unmanaged>
            <unmanaged-short>IDirectManipulationViewport::SetViewportOptions</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectManipulation.Viewport.AddConfiguration(SharpDX.DirectManipulation.Configuration)">
            <summary>
            <p>Adds an interaction configuration for the viewport.</p>
            </summary>
            <param name = "configuration"><dd> <p>One of the values from <strong><see cref = "T:SharpDX.DirectManipulation.Configuration"/></strong> that specifies the interaction configuration for the viewport.</p> </dd></param>
            <returns><p>If the method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>An interaction configuration specifies how the manipulation engine responds to input and which manipulations are supported. Any number of possible configurations can be added to the viewport using <strong>AddConfiguration</strong> before processing input. </p><p>Configurations can be switched by the application at runtime using <strong>ActivateConfiguration</strong>.  </p><p>When a configuration is no longer required (and is not currently active), it can be removed using <strong>RemoveConfiguration</strong>. </p><p>If a configuration has not been added using <strong>AddConfiguration</strong>, it can be automatically added and then activated by calling <strong>ActivateConfiguration</strong>. </p><strong>Note</strong>??If input processing is occurring, this call will fail.?<p>This method fails if a drag and drop behavior has been specified. </p><p>A drag and drop behavior object cannot be attached after successfully calling this method.</p><p>You cannot add another drag and drop behavior after an existing one has already been added.</p><p>This method is designed to allow an application to switch pre-added configurations, as a configuration cannot be changed while a manipulation is occurring. Under most circumstances it is better to update the configuration using <strong>ActivateConfiguration</strong>.</p>
            </remarks>
            <doc-id>hh447156</doc-id>
            <unmanaged>HRESULT IDirectManipulationViewport::AddConfiguration([In] DIRECTMANIPULATION_CONFIGURATION configuration)</unmanaged>
            <unmanaged-short>IDirectManipulationViewport::AddConfiguration</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectManipulation.Viewport.RemoveConfiguration(SharpDX.DirectManipulation.Configuration)">
            <summary>
            <p>Removes an interaction configuration for the viewport.</p>
            </summary>
            <param name = "configuration"><dd> <p>One of the values from <strong><see cref = "T:SharpDX.DirectManipulation.Configuration"/></strong> that specifies the interaction configuration for the viewport.</p> </dd></param>
            <returns><p>If the method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>This method removes a possible configuration that was added by using <strong>AddConfiguration</strong>. This method can be called only if the configuration is not active.</p><p>An interaction configuration specifies how the manipulation engine responds to input and which gestures are supported. Any number of configurations can be added to the viewport using <strong>AddConfiguration</strong>. Configurations can be switched by the application at runtime using <strong>ActivateConfiguration</strong>. When a configuration is no longer required (and is not currently active), it can be removed using <strong>RemoveConfiguration</strong>.</p>
            </remarks>
            <doc-id>hh447170</doc-id>
            <unmanaged>HRESULT IDirectManipulationViewport::RemoveConfiguration([In] DIRECTMANIPULATION_CONFIGURATION configuration)</unmanaged>
            <unmanaged-short>IDirectManipulationViewport::RemoveConfiguration</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectManipulation.Viewport.ActivateConfiguration(SharpDX.DirectManipulation.Configuration)">
            <summary>
            <p>Sets the configuration for input interaction.</p>
            </summary>
            <param name = "configuration"><dd> <p>One or more values from <strong><see cref = "T:SharpDX.DirectManipulation.Configuration"/></strong> that specify the interaction configuration for the viewport.</p> </dd></param>
            <returns><p>If the method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>An interaction configuration specifies how the manipulation engine responds to input and which manipulations are supported. Any number of possible configurations can be added to the viewport using <strong>AddConfiguration</strong> before processing input. </p><p>Configurations can be switched by the application at runtime using <strong>ActivateConfiguration</strong>.  </p><p>When a configuration is no longer required (and is not currently active), it can be removed using <strong>RemoveConfiguration</strong>. </p><p>If a configuration has not been added using <strong>AddConfiguration</strong>, it can be automatically added and then activated by calling <strong>ActivateConfiguration</strong>. </p><strong>Note</strong>??If input processing is occurring, this call will fail.?<p>This method fails if a drag and drop behavior has been specified. </p><p>A drag and drop behavior object cannot be attached after successfully calling this method.</p>
            </remarks>
            <doc-id>hh447154</doc-id>
            <unmanaged>HRESULT IDirectManipulationViewport::ActivateConfiguration([In] DIRECTMANIPULATION_CONFIGURATION configuration)</unmanaged>
            <unmanaged-short>IDirectManipulationViewport::ActivateConfiguration</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectManipulation.Viewport.SetManualGesture(SharpDX.DirectManipulation.GestureConfiguration)">
            <summary>
            <p>Sets which gestures are ignored by Direct Manipulation. </p>
            </summary>
            <param name = "configuration">No documentation.</param>
            <returns><p>If the method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>Use this method to specify which gestures the application processes on the UI thread. If a gesture is recognized, it will be passed to the application for processing and ignored by Direct Manipulation.</p>
            </remarks>
            <doc-id>jj654881</doc-id>
            <unmanaged>HRESULT IDirectManipulationViewport::SetManualGesture([In] DIRECTMANIPULATION_GESTURE_CONFIGURATION configuration)</unmanaged>
            <unmanaged-short>IDirectManipulationViewport::SetManualGesture</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectManipulation.Viewport.SetChaining(SharpDX.DirectManipulation.MotionTypes)">
            <summary>
            <p>Specifies the motion types supported in a viewport that can be chained to a parent viewport.</p>
            </summary>
            <param name = "enabledTypes"><dd> <p>One of the values from <strong><see cref = "T:SharpDX.DirectManipulation.MotionTypes"/></strong> that specifies the motion types that are enabled for this viewport.</p> </dd></param>
            <returns><p>If the method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>hh447174</doc-id>
            <unmanaged>HRESULT IDirectManipulationViewport::SetChaining([In] DIRECTMANIPULATION_MOTION_TYPES enabledTypes)</unmanaged>
            <unmanaged-short>IDirectManipulationViewport::SetChaining</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectManipulation.Viewport.AddEventHandler(System.IntPtr,SharpDX.DirectManipulation.ViewportEventHandler,System.Int32@)">
            <summary>
            <p>Adds a new event handler to listen for viewport events.</p>
            </summary>
            <param name = "window"><dd> <p>The handle of a window owned by the thread for the event callback.</p> </dd></param>
            <param name = "eventHandler"><dd> <p>The handler that is called when viewport status and update events occur. The specified object must implement the <strong><see cref = "T:SharpDX.DirectManipulation.ViewportEventHandler"/></strong> interface.</p> </dd></param>
            <param name = "cookie"><dd> <p>The handle that represents this event handler callback.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>The event callback is fired from the thread that owns the specified window. Consecutive events of the same callback method may be coalesced. 
            </p><strong>Note</strong>??If the viewport has a drag-drop behavior attached, the event handler should implement <strong><see cref = "T:SharpDX.DirectManipulation.DragDropEventHandler"/></strong>.?
            </remarks>
            <doc-id>hh447161</doc-id>
            <unmanaged>HRESULT IDirectManipulationViewport::AddEventHandler([In, Optional] HWND window,[In] IDirectManipulationViewportEventHandler* eventHandler,[Out] DWORD* cookie)</unmanaged>
            <unmanaged-short>IDirectManipulationViewport::AddEventHandler</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectManipulation.Viewport.RemoveEventHandler(System.Int32)">
            <summary>
            <p>Removes an existing event handler from the viewport.</p>
            </summary>
            <param name = "cookie"><dd> <p>A value that was returned by a previous call to <strong>AddEventHandler</strong>.</p> </dd></param>
            <returns><p>If the method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>hh447173</doc-id>
            <unmanaged>HRESULT IDirectManipulationViewport::RemoveEventHandler([In] DWORD cookie)</unmanaged>
            <unmanaged-short>IDirectManipulationViewport::RemoveEventHandler</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectManipulation.Viewport.SetInputMode(SharpDX.DirectManipulation.InputMode)">
            <summary>
            <p>Specifies if input is visible to the UI thread.</p>
            </summary>
            <param name = "mode"><dd> <p>One of the values from <strong><see cref = "T:SharpDX.DirectManipulation.InputMode"/></strong>.</p> </dd></param>
            <returns><p>If the method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>DIRECTMANIPULATION_INPUT_MODE_AUTOMATIC is the default mode for Direct Manipulation. </p><p> Direct Manipulation consumes all the input that drives the manipulation and the application receives WM_POINTERCAPTURECHANGED messages. 
            </p><p>In some situations an application may want to receive input that is driving a manipulation. Set DIRECTMANIPULATION_INPUT_MODE_MANUAL in this case. The application will receive all input messages, even input used by Direct Manipulation to drive a manipulation. </p><strong>Note</strong>??The application will not receive WM_POINTERCAPTURECHANGED messages.?<p>Calling this method with <strong>DIRECTMANIPULATION_INPUT_MODE_MANUAL</strong> set is similar to calling <strong>SetViewportOptions(DIRECTMANIPULATION_VIEWPORT_OPTIONS_INPUT)</strong>. However, calling <strong>SetViewportOptions</strong> also overrides all other settings.</p>
            </remarks>
            <doc-id>hh447176</doc-id>
            <unmanaged>HRESULT IDirectManipulationViewport::SetInputMode([In] DIRECTMANIPULATION_INPUT_MODE mode)</unmanaged>
            <unmanaged-short>IDirectManipulationViewport::SetInputMode</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectManipulation.Viewport.SetUpdateMode(SharpDX.DirectManipulation.InputMode)">
            <summary>
            <p> Specifies whether a viewport updates content manually instead of during an input event.</p>
            </summary>
            <param name = "mode"><dd> <p>One of the values from <strong><see cref = "T:SharpDX.DirectManipulation.InputMode"/></strong>.</p> </dd></param>
            <returns><p>If the method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>DIRECTMANIPULATION_INPUT_MODE_AUTOMATIC is the default mode for Direct Manipulation. In this mode, visual updates are pushed to compositor driven by input. This is the expected mode of operation if the application is using system-provided implementation of <strong><see cref = "T:SharpDX.DirectManipulation.Compositor"/></strong>.
            </p><p>If the application provides its own implementation of <strong><see cref = "T:SharpDX.DirectManipulation.Compositor"/></strong>, it should switch viewport update mode to manual by setting DIRECTMANIPULATION_INPUT_MODE_MANUAL. When in manual mode, the compositor pulls visual updates whenever it calls <strong>Update</strong> on Direct Manipulation.
            </p><p>Calling this method with <strong>DIRECTMANIPULATION_INPUT_MODE_MANUAL</strong> set is similar to calling <strong>SetViewportOptions(DIRECTMANIPULATION_VIEWPORT_OPTIONS_INPUT)</strong>. However, calling <strong>SetViewportOptions</strong> also overrides all other settings.</p>
            </remarks>
            <doc-id>hh768922</doc-id>
            <unmanaged>HRESULT IDirectManipulationViewport::SetUpdateMode([In] DIRECTMANIPULATION_INPUT_MODE mode)</unmanaged>
            <unmanaged-short>IDirectManipulationViewport::SetUpdateMode</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectManipulation.Viewport.Stop">
            <summary>
            <p> Stops the manipulation and returns the viewport to a ready state.  
            </p>
            </summary>
            <returns><p>If the method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>If a mandatory snap point has been configured, the content may animate to the nearest snap point.</p>
            </remarks>
            <doc-id>hh768925</doc-id>
            <unmanaged>HRESULT IDirectManipulationViewport::Stop()</unmanaged>
            <unmanaged-short>IDirectManipulationViewport::Stop</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectManipulation.Viewport.Abandon">
            <summary>
            <p> Releases all resources that are used by the viewport and prepares it for destruction from memory.
            </p>
            </summary>
            <returns><p>If the method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>Once <strong>Abandon</strong> has been called, do not make subsequent function calls on the viewport. If a function is called after <strong>Abandon</strong>, <strong>E_INVALID_STATE</strong> will be returned.</p>
            </remarks>
            <doc-id>hh768916</doc-id>
            <unmanaged>HRESULT IDirectManipulationViewport::Abandon()</unmanaged>
            <unmanaged-short>IDirectManipulationViewport::Abandon</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectManipulation.Viewport2.AddBehavior(SharpDX.IUnknown,System.Int32@)">
            <summary>
            <p>Adds a behavior to the viewport and returns a cookie to the caller.</p>
            </summary>
            <param name = "behavior"><dd> <p>A behavior created using the <strong>CreateBehavior</strong> method.</p> </dd></param>
            <param name = "cookie"><dd> <p>A cookie is returned so the caller can remove this behavior later. This allows the caller to release any reference on the behavior and let Direct Manipulation maintain an appropriate lifetime, similar to event handlers. </p> </dd></param>
            <returns><p>If the method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code. Attaching a behavior that is already attached to this viewport or another viewport results in a failure.</p></returns>
            <remarks>
            <p>A behavior takes effect immediately after <strong>AddBehavior</strong> is called. This must be considered when adding a behavior during an active manipulation or inertia phase.</p>
            </remarks>
            <doc-id>dn280399</doc-id>
            <unmanaged>HRESULT IDirectManipulationViewport2::AddBehavior([In] IUnknown* behavior,[Out] DWORD* cookie)</unmanaged>
            <unmanaged-short>IDirectManipulationViewport2::AddBehavior</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectManipulation.Viewport2.RemoveBehavior(System.Int32)">
            <summary>
            <p>Removes a behavior from the viewport that matches the given cookie.</p>
            </summary>
            <param name = "cookie"><dd> <p>A valid cookie returned from the <strong>AddBehavior</strong> call on the same viewport.</p> </dd></param>
            <returns><p>If the method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code. If the behavior has already been removed or if the behavior is not attached to this viewport a failure is returned.</p></returns>
            <doc-id>dn280401</doc-id>
            <unmanaged>HRESULT IDirectManipulationViewport2::RemoveBehavior([In] DWORD cookie)</unmanaged>
            <unmanaged-short>IDirectManipulationViewport2::RemoveBehavior</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectManipulation.Viewport2.RemoveAllBehaviors">
            <summary>
            <p>Removes all behaviors added to the viewport.</p>
            </summary>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p><strong>RemoveAllBehaviors</strong> only returns an error if the removal of a behavior from the viewport was unsuccessful. In the event that a specific behavior is not removed successfully, <strong>RemoveAllBehaviors</strong> removes all remaining behaviors.</p>
            </remarks>
            <doc-id>dn280400</doc-id>
            <unmanaged>HRESULT IDirectManipulationViewport2::RemoveAllBehaviors()</unmanaged>
            <unmanaged-short>IDirectManipulationViewport2::RemoveAllBehaviors</unmanaged-short>
        </member>
        <member name="T:SharpDX.DirectManipulation.AutoScrollConfiguration">
            <summary>
            <p>Determines the type and direction of automatic scrolling animation to apply. </p>
            </summary>
            <doc-id>dn280383</doc-id>
            <unmanaged>DIRECTMANIPULATION_AUTOSCROLL_CONFIGURATION</unmanaged>
            <unmanaged-short>DIRECTMANIPULATION_AUTOSCROLL_CONFIGURATION</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectManipulation.AutoScrollConfiguration.Stop">
            <summary>
            <dd> <p>If content is scrolling, slowly stop along the direction of the motion.</p> </dd>
            </summary>
            <doc-id>dn280383</doc-id>
            <unmanaged>DIRECTMANIPULATION_AUTOSCROLL_CONFIGURATION_STOP</unmanaged>
            <unmanaged-short>DIRECTMANIPULATION_AUTOSCROLL_CONFIGURATION_STOP</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectManipulation.AutoScrollConfiguration.Forward">
            <summary>
            <dd> <p>Scroll towards the positive boundary of the content.</p> </dd>
            </summary>
            <doc-id>dn280383</doc-id>
            <unmanaged>DIRECTMANIPULATION_AUTOSCROLL_CONFIGURATION_FORWARD</unmanaged>
            <unmanaged-short>DIRECTMANIPULATION_AUTOSCROLL_CONFIGURATION_FORWARD</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectManipulation.AutoScrollConfiguration.Reverse">
            <summary>
            <dd> <p>Scroll towards the origin of the content.</p> </dd>
            </summary>
            <doc-id>dn280383</doc-id>
            <unmanaged>DIRECTMANIPULATION_AUTOSCROLL_CONFIGURATION_REVERSE</unmanaged>
            <unmanaged-short>DIRECTMANIPULATION_AUTOSCROLL_CONFIGURATION_REVERSE</unmanaged-short>
        </member>
        <member name="T:SharpDX.DirectManipulation.Configuration">
            <summary>
            <p>Defines the interaction configuration states available in Direct Manipulation.</p>
            </summary>
            <doc-id>hh446956</doc-id>
            <unmanaged>DIRECTMANIPULATION_CONFIGURATION</unmanaged>
            <unmanaged-short>DIRECTMANIPULATION_CONFIGURATION</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectManipulation.Configuration.None">
            <summary>
            No documentation.
            </summary>
            <doc-id>hh446956</doc-id>
            <unmanaged>DIRECTMANIPULATION_CONFIGURATION_NONE</unmanaged>
            <unmanaged-short>DIRECTMANIPULATION_CONFIGURATION_NONE</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectManipulation.Configuration.Interaction">
            <summary>
            No documentation.
            </summary>
            <doc-id>hh446956</doc-id>
            <unmanaged>DIRECTMANIPULATION_CONFIGURATION_INTERACTION</unmanaged>
            <unmanaged-short>DIRECTMANIPULATION_CONFIGURATION_INTERACTION</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectManipulation.Configuration.TranslationX">
            <summary>
            No documentation.
            </summary>
            <doc-id>hh446956</doc-id>
            <unmanaged>DIRECTMANIPULATION_CONFIGURATION_TRANSLATION_X</unmanaged>
            <unmanaged-short>DIRECTMANIPULATION_CONFIGURATION_TRANSLATION_X</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectManipulation.Configuration.TranslationY">
            <summary>
            No documentation.
            </summary>
            <doc-id>hh446956</doc-id>
            <unmanaged>DIRECTMANIPULATION_CONFIGURATION_TRANSLATION_Y</unmanaged>
            <unmanaged-short>DIRECTMANIPULATION_CONFIGURATION_TRANSLATION_Y</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectManipulation.Configuration.Scaling">
            <summary>
            No documentation.
            </summary>
            <doc-id>hh446956</doc-id>
            <unmanaged>DIRECTMANIPULATION_CONFIGURATION_SCALING</unmanaged>
            <unmanaged-short>DIRECTMANIPULATION_CONFIGURATION_SCALING</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectManipulation.Configuration.TranslationInertia">
            <summary>
            No documentation.
            </summary>
            <doc-id>hh446956</doc-id>
            <unmanaged>DIRECTMANIPULATION_CONFIGURATION_TRANSLATION_INERTIA</unmanaged>
            <unmanaged-short>DIRECTMANIPULATION_CONFIGURATION_TRANSLATION_INERTIA</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectManipulation.Configuration.ScalingInertia">
            <summary>
            No documentation.
            </summary>
            <doc-id>hh446956</doc-id>
            <unmanaged>DIRECTMANIPULATION_CONFIGURATION_SCALING_INERTIA</unmanaged>
            <unmanaged-short>DIRECTMANIPULATION_CONFIGURATION_SCALING_INERTIA</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectManipulation.Configuration.RailsX">
            <summary>
            No documentation.
            </summary>
            <doc-id>hh446956</doc-id>
            <unmanaged>DIRECTMANIPULATION_CONFIGURATION_RAILS_X</unmanaged>
            <unmanaged-short>DIRECTMANIPULATION_CONFIGURATION_RAILS_X</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectManipulation.Configuration.RailsY">
            <summary>
            No documentation.
            </summary>
            <doc-id>hh446956</doc-id>
            <unmanaged>DIRECTMANIPULATION_CONFIGURATION_RAILS_Y</unmanaged>
            <unmanaged-short>DIRECTMANIPULATION_CONFIGURATION_RAILS_Y</unmanaged-short>
        </member>
        <member name="T:SharpDX.DirectManipulation.DragDropConfiguration">
            <summary>
            <p>Defines behaviors for the drag-drop interaction.</p>
            </summary>
            <doc-id>dn280384</doc-id>
            <unmanaged>DIRECTMANIPULATION_DRAG_DROP_CONFIGURATION</unmanaged>
            <unmanaged-short>DIRECTMANIPULATION_DRAG_DROP_CONFIGURATION</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectManipulation.DragDropConfiguration.Vertical">
            <summary>
            <dd> <p>Specifies that vertical movement is applicable to the chosen gesture.</p> </dd>
            </summary>
            <doc-id>dn280384</doc-id>
            <unmanaged>DIRECTMANIPULATION_DRAG_DROP_CONFIGURATION_VERTICAL</unmanaged>
            <unmanaged-short>DIRECTMANIPULATION_DRAG_DROP_CONFIGURATION_VERTICAL</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectManipulation.DragDropConfiguration.Horizontal">
            <summary>
            <dd> <p>Specifies that horizontal movement is applicable to the chosen gesture.</p> </dd>
            </summary>
            <doc-id>dn280384</doc-id>
            <unmanaged>DIRECTMANIPULATION_DRAG_DROP_CONFIGURATION_HORIZONTAL</unmanaged>
            <unmanaged-short>DIRECTMANIPULATION_DRAG_DROP_CONFIGURATION_HORIZONTAL</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectManipulation.DragDropConfiguration.SelectOnly">
            <summary>
            <dd> <p>Specifies that the gesture is to be cross-slide only.</p> </dd>
            </summary>
            <doc-id>dn280384</doc-id>
            <unmanaged>DIRECTMANIPULATION_DRAG_DROP_CONFIGURATION_SELECT_ONLY</unmanaged>
            <unmanaged-short>DIRECTMANIPULATION_DRAG_DROP_CONFIGURATION_SELECT_ONLY</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectManipulation.DragDropConfiguration.SelectDrag">
            <summary>
            <dd> <p>Specifies that the gesture is a drag initiated by cross-slide.</p> </dd>
            </summary>
            <doc-id>dn280384</doc-id>
            <unmanaged>DIRECTMANIPULATION_DRAG_DROP_CONFIGURATION_SELECT_DRAG</unmanaged>
            <unmanaged-short>DIRECTMANIPULATION_DRAG_DROP_CONFIGURATION_SELECT_DRAG</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectManipulation.DragDropConfiguration.HoldDrag">
            <summary>
            <dd> <p>Specifies that the gesture a drag initiated by press-and-hold.</p> </dd>
            </summary>
            <doc-id>dn280384</doc-id>
            <unmanaged>DIRECTMANIPULATION_DRAG_DROP_CONFIGURATION_HOLD_DRAG</unmanaged>
            <unmanaged-short>DIRECTMANIPULATION_DRAG_DROP_CONFIGURATION_HOLD_DRAG</unmanaged-short>
        </member>
        <member name="T:SharpDX.DirectManipulation.DragDropStatus">
            <summary>
            <p>Defines the drag-and-drop interaction states for the viewport.</p>
            </summary>
            <remarks>
            <p>For each interaction, the status always starts at <strong>DIRECTMANIPULATION_DRAG_DROP_READY</strong> and ends at either <strong>DIRECTMANIPULATION_DRAG_DROP_CANCELLED</strong> or <strong>DIRECTMANIPULATION_DRAG_DROP_COMMITTED</strong>. There are no explicit callbacks for the transition from CANCELLED/COMMITTED to READY.
            </p><p>The meaning of the CANCELLED and COMMITED values depend on the previous status.</p><ul> <li>For <strong>DIRECTMANIPULATION_DRAG_DROP_PRESELECT</strong>, they mean the same thing: the content goes back to the original location and no other actions should be taken.</li> <li>FOR <strong>DIRECTMANIPULATION_DRAG_DROP_SELECTING</strong>, COMMITED means apply the selection change; CANCELLED means avoid the selection change.</li> <li>For <strong>DIRECTMANIPULATION_DRAG_DROP_DRAGGING</strong>, COMMITED means perform the drop action; CANCELLED means cancel the drop action.</li> </ul>
            </remarks>
            <doc-id>dn280385</doc-id>
            <unmanaged>DIRECTMANIPULATION_DRAG_DROP_STATUS</unmanaged>
            <unmanaged-short>DIRECTMANIPULATION_DRAG_DROP_STATUS</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectManipulation.DragDropStatus.Ready">
            <summary>
            <dd> <p>The viewport is at rest and ready for input.</p> </dd>
            </summary>
            <doc-id>dn280385</doc-id>
            <unmanaged>DIRECTMANIPULATION_DRAG_DROP_READY</unmanaged>
            <unmanaged-short>DIRECTMANIPULATION_DRAG_DROP_READY</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectManipulation.DragDropStatus.Preselect">
            <summary>
            <dd> <p>The viewport is updating its content and the content is not selected.</p> </dd>
            </summary>
            <doc-id>dn280385</doc-id>
            <unmanaged>DIRECTMANIPULATION_DRAG_DROP_PRESELECT</unmanaged>
            <unmanaged-short>DIRECTMANIPULATION_DRAG_DROP_PRESELECT</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectManipulation.DragDropStatus.Selecting">
            <summary>
            <dd> <p>The viewport is updating its content and the content is selected.</p> </dd>
            </summary>
            <doc-id>dn280385</doc-id>
            <unmanaged>DIRECTMANIPULATION_DRAG_DROP_SELECTING</unmanaged>
            <unmanaged-short>DIRECTMANIPULATION_DRAG_DROP_SELECTING</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectManipulation.DragDropStatus.Dragging">
            <summary>
            <dd> <p>The viewport is updating its content and the content is being dragged.</p> </dd>
            </summary>
            <doc-id>dn280385</doc-id>
            <unmanaged>DIRECTMANIPULATION_DRAG_DROP_DRAGGING</unmanaged>
            <unmanaged-short>DIRECTMANIPULATION_DRAG_DROP_DRAGGING</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectManipulation.DragDropStatus.Cancelled">
            <summary>
            <dd> <p>The viewport has concluded the interaction and requests a revert.</p> </dd>
            </summary>
            <doc-id>dn280385</doc-id>
            <unmanaged>DIRECTMANIPULATION_DRAG_DROP_CANCELLED</unmanaged>
            <unmanaged-short>DIRECTMANIPULATION_DRAG_DROP_CANCELLED</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectManipulation.DragDropStatus.Committed">
            <summary>
            <dd> <p>The viewport has concluded the interaction and requests a commit.</p> </dd>
            </summary>
            <doc-id>dn280385</doc-id>
            <unmanaged>DIRECTMANIPULATION_DRAG_DROP_COMMITTED</unmanaged>
            <unmanaged-short>DIRECTMANIPULATION_DRAG_DROP_COMMITTED</unmanaged-short>
        </member>
        <member name="T:SharpDX.DirectManipulation.GestureConfiguration">
            <summary>
            <p>Defines the gestures that can be passed to <strong>SetManualGesture</strong>.</p>
            </summary>
            <remarks>
            <p>By default, Direct Manipulation always reassigns tap and press-and-hold gestures to the application. 
            </p><p>Use <strong>DIRECTMANIPULATION_GESTURE_PINCH_ZOOM</strong> to zoom instead of scale.
            </p>
            </remarks>
            <doc-id>jj647928</doc-id>
            <unmanaged>DIRECTMANIPULATION_GESTURE_CONFIGURATION</unmanaged>
            <unmanaged-short>DIRECTMANIPULATION_GESTURE_CONFIGURATION</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectManipulation.GestureConfiguration.None">
            <summary>
            No documentation.
            </summary>
            <doc-id>jj647928</doc-id>
            <unmanaged>DIRECTMANIPULATION_GESTURE_NONE</unmanaged>
            <unmanaged-short>DIRECTMANIPULATION_GESTURE_NONE</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectManipulation.GestureConfiguration.Default">
            <summary>
            No documentation.
            </summary>
            <doc-id>jj647928</doc-id>
            <unmanaged>DIRECTMANIPULATION_GESTURE_DEFAULT</unmanaged>
            <unmanaged-short>DIRECTMANIPULATION_GESTURE_DEFAULT</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectManipulation.GestureConfiguration.CrossSlideVertical">
            <summary>
            No documentation.
            </summary>
            <doc-id>jj647928</doc-id>
            <unmanaged>DIRECTMANIPULATION_GESTURE_CROSS_SLIDE_VERTICAL</unmanaged>
            <unmanaged-short>DIRECTMANIPULATION_GESTURE_CROSS_SLIDE_VERTICAL</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectManipulation.GestureConfiguration.CrossSlideHorizontal">
            <summary>
            No documentation.
            </summary>
            <doc-id>jj647928</doc-id>
            <unmanaged>DIRECTMANIPULATION_GESTURE_CROSS_SLIDE_HORIZONTAL</unmanaged>
            <unmanaged-short>DIRECTMANIPULATION_GESTURE_CROSS_SLIDE_HORIZONTAL</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectManipulation.GestureConfiguration.PinchZoom">
            <summary>
            No documentation.
            </summary>
            <doc-id>jj647928</doc-id>
            <unmanaged>DIRECTMANIPULATION_GESTURE_PINCH_ZOOM</unmanaged>
            <unmanaged-short>DIRECTMANIPULATION_GESTURE_PINCH_ZOOM</unmanaged-short>
        </member>
        <member name="T:SharpDX.DirectManipulation.HitTestType">
            <summary>
            <p>Defines how hit testing is handled by Direct Manipulation when using a dedicated hit-test thread registered through <strong>RegisterHitTestTarget</strong>.</p>
            </summary>
            <doc-id>hh768894</doc-id>
            <unmanaged>DIRECTMANIPULATION_HITTEST_TYPE</unmanaged>
            <unmanaged-short>DIRECTMANIPULATION_HITTEST_TYPE</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectManipulation.HitTestType.Asynchronous">
            <summary>
            No documentation.
            </summary>
            <doc-id>hh768894</doc-id>
            <unmanaged>DIRECTMANIPULATION_HITTEST_TYPE_ASYNCHRONOUS</unmanaged>
            <unmanaged-short>DIRECTMANIPULATION_HITTEST_TYPE_ASYNCHRONOUS</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectManipulation.HitTestType.Synchronous">
            <summary>
            No documentation.
            </summary>
            <doc-id>hh768894</doc-id>
            <unmanaged>DIRECTMANIPULATION_HITTEST_TYPE_SYNCHRONOUS</unmanaged>
            <unmanaged-short>DIRECTMANIPULATION_HITTEST_TYPE_SYNCHRONOUS</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectManipulation.HitTestType.AutoSynchronous">
            <summary>
            No documentation.
            </summary>
            <doc-id>hh768894</doc-id>
            <unmanaged>DIRECTMANIPULATION_HITTEST_TYPE_AUTO_SYNCHRONOUS</unmanaged>
            <unmanaged-short>DIRECTMANIPULATION_HITTEST_TYPE_AUTO_SYNCHRONOUS</unmanaged-short>
        </member>
        <member name="T:SharpDX.DirectManipulation.HorizontalAlignment">
            <summary>
            <p>Defines the horizontal alignment options for content within a viewport.</p>
            </summary>
            <doc-id>hh446957</doc-id>
            <unmanaged>DIRECTMANIPULATION_HORIZONTALALIGNMENT</unmanaged>
            <unmanaged-short>DIRECTMANIPULATION_HORIZONTALALIGNMENT</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectManipulation.HorizontalAlignment.None">
            <summary>
            <dd> <p>No alignment. The object can be positioned anywhere within the viewport.</p> </dd>
            </summary>
            <doc-id>hh446957</doc-id>
            <unmanaged>DIRECTMANIPULATION_HORIZONTALALIGNMENT_NONE</unmanaged>
            <unmanaged-short>DIRECTMANIPULATION_HORIZONTALALIGNMENT_NONE</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectManipulation.HorizontalAlignment.Left">
            <summary>
            <dd> <p>Align object along the left side of the viewport.</p> </dd>
            </summary>
            <doc-id>hh446957</doc-id>
            <unmanaged>DIRECTMANIPULATION_HORIZONTALALIGNMENT_LEFT</unmanaged>
            <unmanaged-short>DIRECTMANIPULATION_HORIZONTALALIGNMENT_LEFT</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectManipulation.HorizontalAlignment.Center">
            <summary>
            <dd> <p>Align object to the center of the viewport.</p> </dd>
            </summary>
            <doc-id>hh446957</doc-id>
            <unmanaged>DIRECTMANIPULATION_HORIZONTALALIGNMENT_CENTER</unmanaged>
            <unmanaged-short>DIRECTMANIPULATION_HORIZONTALALIGNMENT_CENTER</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectManipulation.HorizontalAlignment.Right">
            <summary>
            <dd> <p>Align object along the right side of the viewport.</p> </dd>
            </summary>
            <doc-id>hh446957</doc-id>
            <unmanaged>DIRECTMANIPULATION_HORIZONTALALIGNMENT_RIGHT</unmanaged>
            <unmanaged-short>DIRECTMANIPULATION_HORIZONTALALIGNMENT_RIGHT</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectManipulation.HorizontalAlignment.UnlockCenter">
            <summary>
            <dd> <p>Content zooms around the center point of the contacts, instead of being locked with the horizontal alignment.</p> </dd>
            </summary>
            <doc-id>hh446957</doc-id>
            <unmanaged>DIRECTMANIPULATION_HORIZONTALALIGNMENT_UNLOCKCENTER</unmanaged>
            <unmanaged-short>DIRECTMANIPULATION_HORIZONTALALIGNMENT_UNLOCKCENTER</unmanaged-short>
        </member>
        <member name="T:SharpDX.DirectManipulation.InputMode">
            <summary>
            <p>Defines the threading behavior for <strong>SetInputMode</strong> or <strong>SetUpdateMode</strong>. The exact meaning of each constant depends on the method called.</p>
            </summary>
            <doc-id>hh446958</doc-id>
            <unmanaged>DIRECTMANIPULATION_INPUT_MODE</unmanaged>
            <unmanaged-short>DIRECTMANIPULATION_INPUT_MODE</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectManipulation.InputMode.Automatic">
            <summary>
            No documentation.
            </summary>
            <doc-id>hh446958</doc-id>
            <unmanaged>DIRECTMANIPULATION_INPUT_MODE_AUTOMATIC</unmanaged>
            <unmanaged-short>DIRECTMANIPULATION_INPUT_MODE_AUTOMATIC</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectManipulation.InputMode.Manual">
            <summary>
            No documentation.
            </summary>
            <doc-id>hh446958</doc-id>
            <unmanaged>DIRECTMANIPULATION_INPUT_MODE_MANUAL</unmanaged>
            <unmanaged-short>DIRECTMANIPULATION_INPUT_MODE_MANUAL</unmanaged-short>
        </member>
        <member name="T:SharpDX.DirectManipulation.InteractionType">
            <summary>
            <p>Defines gestures recognized by Direct Manipulation.</p>
            </summary>
            <doc-id>dn280386</doc-id>
            <unmanaged>DIRECTMANIPULATION_INTERACTION_TYPE</unmanaged>
            <unmanaged-short>DIRECTMANIPULATION_INTERACTION_TYPE</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectManipulation.InteractionType.Begin">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn280386</doc-id>
            <unmanaged>DIRECTMANIPULATION_INTERACTION_BEGIN</unmanaged>
            <unmanaged-short>DIRECTMANIPULATION_INTERACTION_BEGIN</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectManipulation.InteractionType.TypeManipulation">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn280386</doc-id>
            <unmanaged>DIRECTMANIPULATION_INTERACTION_TYPE_MANIPULATION</unmanaged>
            <unmanaged-short>DIRECTMANIPULATION_INTERACTION_TYPE_MANIPULATION</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectManipulation.InteractionType.TypeGestureTap">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn280386</doc-id>
            <unmanaged>DIRECTMANIPULATION_INTERACTION_TYPE_GESTURE_TAP</unmanaged>
            <unmanaged-short>DIRECTMANIPULATION_INTERACTION_TYPE_GESTURE_TAP</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectManipulation.InteractionType.TypeGestureHold">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn280386</doc-id>
            <unmanaged>DIRECTMANIPULATION_INTERACTION_TYPE_GESTURE_HOLD</unmanaged>
            <unmanaged-short>DIRECTMANIPULATION_INTERACTION_TYPE_GESTURE_HOLD</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectManipulation.InteractionType.TypeGestureCrossSlide">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn280386</doc-id>
            <unmanaged>DIRECTMANIPULATION_INTERACTION_TYPE_GESTURE_CROSS_SLIDE</unmanaged>
            <unmanaged-short>DIRECTMANIPULATION_INTERACTION_TYPE_GESTURE_CROSS_SLIDE</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectManipulation.InteractionType.TypeGesturePinchZoom">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn280386</doc-id>
            <unmanaged>DIRECTMANIPULATION_INTERACTION_TYPE_GESTURE_PINCH_ZOOM</unmanaged>
            <unmanaged-short>DIRECTMANIPULATION_INTERACTION_TYPE_GESTURE_PINCH_ZOOM</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectManipulation.InteractionType.End">
            <summary>
            No documentation.
            </summary>
            <doc-id>dn280386</doc-id>
            <unmanaged>DIRECTMANIPULATION_INTERACTION_END</unmanaged>
            <unmanaged-short>DIRECTMANIPULATION_INTERACTION_END</unmanaged-short>
        </member>
        <member name="T:SharpDX.DirectManipulation.MotionTypes">
            <summary>
            <p> Defines the Direct Manipulation motion type.</p>
            </summary>
            <doc-id>hh446960</doc-id>
            <unmanaged>DIRECTMANIPULATION_MOTION_TYPES</unmanaged>
            <unmanaged-short>DIRECTMANIPULATION_MOTION_TYPES</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectManipulation.MotionTypes.None">
            <summary>
            No documentation.
            </summary>
            <doc-id>hh446960</doc-id>
            <unmanaged>DIRECTMANIPULATION_MOTION_NONE</unmanaged>
            <unmanaged-short>DIRECTMANIPULATION_MOTION_NONE</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectManipulation.MotionTypes.Translatex">
            <summary>
            No documentation.
            </summary>
            <doc-id>hh446960</doc-id>
            <unmanaged>DIRECTMANIPULATION_MOTION_TRANSLATEX</unmanaged>
            <unmanaged-short>DIRECTMANIPULATION_MOTION_TRANSLATEX</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectManipulation.MotionTypes.Translatey">
            <summary>
            No documentation.
            </summary>
            <doc-id>hh446960</doc-id>
            <unmanaged>DIRECTMANIPULATION_MOTION_TRANSLATEY</unmanaged>
            <unmanaged-short>DIRECTMANIPULATION_MOTION_TRANSLATEY</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectManipulation.MotionTypes.Zoom">
            <summary>
            No documentation.
            </summary>
            <doc-id>hh446960</doc-id>
            <unmanaged>DIRECTMANIPULATION_MOTION_ZOOM</unmanaged>
            <unmanaged-short>DIRECTMANIPULATION_MOTION_ZOOM</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectManipulation.MotionTypes.Centerx">
            <summary>
            No documentation.
            </summary>
            <doc-id>hh446960</doc-id>
            <unmanaged>DIRECTMANIPULATION_MOTION_CENTERX</unmanaged>
            <unmanaged-short>DIRECTMANIPULATION_MOTION_CENTERX</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectManipulation.MotionTypes.Centery">
            <summary>
            No documentation.
            </summary>
            <doc-id>hh446960</doc-id>
            <unmanaged>DIRECTMANIPULATION_MOTION_CENTERY</unmanaged>
            <unmanaged-short>DIRECTMANIPULATION_MOTION_CENTERY</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectManipulation.MotionTypes.All">
            <summary>
            No documentation.
            </summary>
            <doc-id>hh446960</doc-id>
            <unmanaged>DIRECTMANIPULATION_MOTION_ALL</unmanaged>
            <unmanaged-short>DIRECTMANIPULATION_MOTION_ALL</unmanaged-short>
        </member>
        <member name="T:SharpDX.DirectManipulation.SnapPointCoordinate">
            <summary>
            <p>Defines the coordinate system for a collection of snap points.</p>
            </summary>
            <remarks>
            <p>If <strong>DIRECTMANIPULATION_COORDINATE_ORIGIN</strong> and <strong>DIRECTMANIPULATION_COORDINATE_MIRRORED</strong> are both specified, the snap points are interpreted as specified from the bottom and right boundaries of the content (the size of the content - the size of the viewport). This is intended for RTL reading scenarios where content is normally specified and rendered from right-to-left or bottom-to-top.</p>
            </remarks>
            <doc-id>hh768895</doc-id>
            <unmanaged>DIRECTMANIPULATION_SNAPPOINT_COORDINATE</unmanaged>
            <unmanaged-short>DIRECTMANIPULATION_SNAPPOINT_COORDINATE</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectManipulation.SnapPointCoordinate.CoordinateBoundary">
            <summary>
            <dd> <p>Default. </p> <p>Snap points are specified relative to the top and left boundaries of the content unless <strong>DIRECTMANIPULATION_COORDINATE_MIRRORED</strong> is also specified, in which case they are relative to the bottom and right boundaries of the content. For zoom, the boundary is 1.0f.</p> </dd>
            </summary>
            <doc-id>hh768895</doc-id>
            <unmanaged>DIRECTMANIPULATION_COORDINATE_BOUNDARY</unmanaged>
            <unmanaged-short>DIRECTMANIPULATION_COORDINATE_BOUNDARY</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectManipulation.SnapPointCoordinate.CoordinateOrigin">
            <summary>
            <dd> <p>Snap points are specified relative to the origin of the viewport.</p> </dd>
            </summary>
            <doc-id>hh768895</doc-id>
            <unmanaged>DIRECTMANIPULATION_COORDINATE_ORIGIN</unmanaged>
            <unmanaged-short>DIRECTMANIPULATION_COORDINATE_ORIGIN</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectManipulation.SnapPointCoordinate.CoordinateMirrorEd">
            <summary>
            <dd> <p>Snap points are interpreted as specified in the negative direction of the origin. The origin is shifted to the bottom and right of the viewport or content. Cannot be set for zoom.</p> </dd>
            </summary>
            <doc-id>hh768895</doc-id>
            <unmanaged>DIRECTMANIPULATION_COORDINATE_MIRRORED</unmanaged>
            <unmanaged-short>DIRECTMANIPULATION_COORDINATE_MIRRORED</unmanaged-short>
        </member>
        <member name="T:SharpDX.DirectManipulation.SnapPointType">
            <summary>
            <p>Modifies how the final inertia end position is calculated.</p>
            </summary>
            <remarks>
            <p>For <strong>DIRECTMANIPULATION_SNAPPOINT_MANDATORY</strong> or <strong>DIRECTMANIPULATION_SNAPPOINT_OPTIONAL</strong> snap points, the snap points are chosen based on the natural ending position of inertia as calculated by the touch interaction engine. For <strong>DIRECTMANIPULATION_SNAPPOINT_MANDATORY_SINGLE</strong> or <strong>DIRECTMANIPULATION_SNAPPOINT_OPTIONAL_SINGLE</strong> snap points, the selected snap point depends on where inertia started.</p>
            </remarks>
            <doc-id>hh768896</doc-id>
            <unmanaged>DIRECTMANIPULATION_SNAPPOINT_TYPE</unmanaged>
            <unmanaged-short>DIRECTMANIPULATION_SNAPPOINT_TYPE</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectManipulation.SnapPointType.Mandatory">
            <summary>
            <dd> <p>Content always stops at the snap point closest to where inertia would naturally stop along the direction of inertia.</p> </dd>
            </summary>
            <doc-id>hh768896</doc-id>
            <unmanaged>DIRECTMANIPULATION_SNAPPOINT_MANDATORY</unmanaged>
            <unmanaged-short>DIRECTMANIPULATION_SNAPPOINT_MANDATORY</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectManipulation.SnapPointType.Optional">
            <summary>
            <dd> <p>Content stops at a snap point closest to where inertia would naturally stop along the direction of inertia, depending on how close the snap point is. </p> </dd>
            </summary>
            <doc-id>hh768896</doc-id>
            <unmanaged>DIRECTMANIPULATION_SNAPPOINT_OPTIONAL</unmanaged>
            <unmanaged-short>DIRECTMANIPULATION_SNAPPOINT_OPTIONAL</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectManipulation.SnapPointType.MandatorySingle">
            <summary>
            <dd> <p>Content always stops at the snap point closest to the release point along the direction of inertia.</p> </dd>
            </summary>
            <doc-id>hh768896</doc-id>
            <unmanaged>DIRECTMANIPULATION_SNAPPOINT_MANDATORY_SINGLE</unmanaged>
            <unmanaged-short>DIRECTMANIPULATION_SNAPPOINT_MANDATORY_SINGLE</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectManipulation.SnapPointType.OptionalSingle">
            <summary>
            <dd> <p>Content stops at the next snap point, if the motion starts far from it.</p> </dd>
            </summary>
            <doc-id>hh768896</doc-id>
            <unmanaged>DIRECTMANIPULATION_SNAPPOINT_OPTIONAL_SINGLE</unmanaged>
            <unmanaged-short>DIRECTMANIPULATION_SNAPPOINT_OPTIONAL_SINGLE</unmanaged-short>
        </member>
        <member name="T:SharpDX.DirectManipulation.Status">
            <summary>
            <p>Defines the possible states of Direct Manipulation. The viewport can process input in any state unless otherwise noted.</p>
            </summary>
            <doc-id>hh446962</doc-id>
            <unmanaged>DIRECTMANIPULATION_STATUS</unmanaged>
            <unmanaged-short>DIRECTMANIPULATION_STATUS</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectManipulation.Status.Building">
            <summary>
            No documentation.
            </summary>
            <doc-id>hh446962</doc-id>
            <unmanaged>DIRECTMANIPULATION_BUILDING</unmanaged>
            <unmanaged-short>DIRECTMANIPULATION_BUILDING</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectManipulation.Status.Enabled">
            <summary>
            No documentation.
            </summary>
            <doc-id>hh446962</doc-id>
            <unmanaged>DIRECTMANIPULATION_ENABLED</unmanaged>
            <unmanaged-short>DIRECTMANIPULATION_ENABLED</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectManipulation.Status.Disabled">
            <summary>
            No documentation.
            </summary>
            <doc-id>hh446962</doc-id>
            <unmanaged>DIRECTMANIPULATION_DISABLED</unmanaged>
            <unmanaged-short>DIRECTMANIPULATION_DISABLED</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectManipulation.Status.Running">
            <summary>
            No documentation.
            </summary>
            <doc-id>hh446962</doc-id>
            <unmanaged>DIRECTMANIPULATION_RUNNING</unmanaged>
            <unmanaged-short>DIRECTMANIPULATION_RUNNING</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectManipulation.Status.Inertia">
            <summary>
            No documentation.
            </summary>
            <doc-id>hh446962</doc-id>
            <unmanaged>DIRECTMANIPULATION_INERTIA</unmanaged>
            <unmanaged-short>DIRECTMANIPULATION_INERTIA</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectManipulation.Status.Ready">
            <summary>
            No documentation.
            </summary>
            <doc-id>hh446962</doc-id>
            <unmanaged>DIRECTMANIPULATION_READY</unmanaged>
            <unmanaged-short>DIRECTMANIPULATION_READY</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectManipulation.Status.Suspended">
            <summary>
            No documentation.
            </summary>
            <doc-id>hh446962</doc-id>
            <unmanaged>DIRECTMANIPULATION_SUSPENDED</unmanaged>
            <unmanaged-short>DIRECTMANIPULATION_SUSPENDED</unmanaged-short>
        </member>
        <member name="T:SharpDX.DirectManipulation.VerticalAlignment">
            <summary>
            <p>Defines  the vertical alignment settings for content within the viewport.</p>
            </summary>
            <doc-id>hh446964</doc-id>
            <unmanaged>DIRECTMANIPULATION_VERTICALALIGNMENT</unmanaged>
            <unmanaged-short>DIRECTMANIPULATION_VERTICALALIGNMENT</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectManipulation.VerticalAlignment.None">
            <summary>
            <dd> <p>No alignment. The object can be positioned anywhere within the viewport.</p> </dd>
            </summary>
            <doc-id>hh446964</doc-id>
            <unmanaged>DIRECTMANIPULATION_VERTICALALIGNMENT_NONE</unmanaged>
            <unmanaged-short>DIRECTMANIPULATION_VERTICALALIGNMENT_NONE</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectManipulation.VerticalAlignment.Top">
            <summary>
            <dd> <p>Align object along the top of the viewport.</p> </dd>
            </summary>
            <doc-id>hh446964</doc-id>
            <unmanaged>DIRECTMANIPULATION_VERTICALALIGNMENT_TOP</unmanaged>
            <unmanaged-short>DIRECTMANIPULATION_VERTICALALIGNMENT_TOP</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectManipulation.VerticalAlignment.Center">
            <summary>
            <dd> <p>Align object to the center of the viewport.</p> </dd>
            </summary>
            <doc-id>hh446964</doc-id>
            <unmanaged>DIRECTMANIPULATION_VERTICALALIGNMENT_CENTER</unmanaged>
            <unmanaged-short>DIRECTMANIPULATION_VERTICALALIGNMENT_CENTER</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectManipulation.VerticalAlignment.Bottom">
            <summary>
            <dd> <p>Align object along the bottom of the viewport.</p> </dd>
            </summary>
            <doc-id>hh446964</doc-id>
            <unmanaged>DIRECTMANIPULATION_VERTICALALIGNMENT_BOTTOM</unmanaged>
            <unmanaged-short>DIRECTMANIPULATION_VERTICALALIGNMENT_BOTTOM</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectManipulation.VerticalAlignment.UnlockCenter">
            <summary>
            <dd> <p>Content zooms around the center point of the contacts, instead of being locked with the vertical alignment.</p> </dd>
            </summary>
            <doc-id>hh446964</doc-id>
            <unmanaged>DIRECTMANIPULATION_VERTICALALIGNMENT_UNLOCKCENTER</unmanaged>
            <unmanaged-short>DIRECTMANIPULATION_VERTICALALIGNMENT_UNLOCKCENTER</unmanaged-short>
        </member>
        <member name="T:SharpDX.DirectManipulation.ViewportOptions">
            <summary>
            <p>Defines the input behavior options for the viewport.</p>
            </summary>
            <remarks>
            <p><strong><see cref = "T:SharpDX.DirectManipulation.ViewportOptions"/></strong> is used in the <strong>SetViewportOptions</strong> method. These flags can be combined to set the input behavior for a viewport.</p>
            </remarks>
            <doc-id>jj647929</doc-id>
            <unmanaged>DIRECTMANIPULATION_VIEWPORT_OPTIONS</unmanaged>
            <unmanaged-short>DIRECTMANIPULATION_VIEWPORT_OPTIONS</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectManipulation.ViewportOptions.Default">
            <summary>
            <dd> <p>No special behaviors. This is the default value used to set or revert to default behavior.</p> </dd>
            </summary>
            <doc-id>jj647929</doc-id>
            <unmanaged>DIRECTMANIPULATION_VIEWPORT_OPTIONS_DEFAULT</unmanaged>
            <unmanaged-short>DIRECTMANIPULATION_VIEWPORT_OPTIONS_DEFAULT</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectManipulation.ViewportOptions.AutoDisable">
            <summary>
            <dd> <p>At the end of an interaction, the viewport transitions to <strong>DIRECTMANIPULATION_READY</strong> and then immediately to <strong>DIRECTMANIPULATION_DISABLED</strong>. The viewport must be explicitly enabled through the <strong>Enable</strong> method before the next interaction can be processed.</p> </dd>
            </summary>
            <doc-id>jj647929</doc-id>
            <unmanaged>DIRECTMANIPULATION_VIEWPORT_OPTIONS_AUTODISABLE</unmanaged>
            <unmanaged-short>DIRECTMANIPULATION_VIEWPORT_OPTIONS_AUTODISABLE</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectManipulation.ViewportOptions.ManualUpdate">
            <summary>
            <dd> <p> <strong>Update</strong> must be called to redraw the content within the viewport. The content is not updated automatically during an input event.</p> </dd>
            </summary>
            <doc-id>jj647929</doc-id>
            <unmanaged>DIRECTMANIPULATION_VIEWPORT_OPTIONS_MANUALUPDATE</unmanaged>
            <unmanaged-short>DIRECTMANIPULATION_VIEWPORT_OPTIONS_MANUALUPDATE</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectManipulation.ViewportOptions.Input">
            <summary>
            <dd> <p>All input from a contact associated with the viewport is passed to the UI thread for processing.</p> </dd>
            </summary>
            <doc-id>jj647929</doc-id>
            <unmanaged>DIRECTMANIPULATION_VIEWPORT_OPTIONS_INPUT</unmanaged>
            <unmanaged-short>DIRECTMANIPULATION_VIEWPORT_OPTIONS_INPUT</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectManipulation.ViewportOptions.ExplicitHitTest">
            <summary>
            <dd> <p>If set, all <strong>WM_POINTERDOWN</strong> messages are passed to the application for hit testing. Otherwise, Direct Manipulation will process the messages for hit testing against the existing list of running viewports, and the application will not see the input.</p> <p>Applies only when viewport state is <strong>DIRECTMANIPULATION_RUNNING</strong> or <strong>DIRECTMANIPULATION_INERTIA</strong>.</p> </dd>
            </summary>
            <doc-id>jj647929</doc-id>
            <unmanaged>DIRECTMANIPULATION_VIEWPORT_OPTIONS_EXPLICITHITTEST</unmanaged>
            <unmanaged-short>DIRECTMANIPULATION_VIEWPORT_OPTIONS_EXPLICITHITTEST</unmanaged-short>
        </member>
        <member name="F:SharpDX.DirectManipulation.ViewportOptions.Disablepixelsnapping">
            <summary>
            <dd> <p>Specifies that pixel snapping during a manipulation is disabled.</p> <p>Anti-aliasing can create irregular edge rendering. Artifacts, commonly seen as blurry, or semi-transparent, edges can occur when the location of an edge falls in the middle of a device pixel rather than between device pixels. </p> </dd>
            </summary>
            <doc-id>jj647929</doc-id>
            <unmanaged>DIRECTMANIPULATION_VIEWPORT_OPTIONS_DISABLEPIXELSNAPPING</unmanaged>
            <unmanaged-short>DIRECTMANIPULATION_VIEWPORT_OPTIONS_DISABLEPIXELSNAPPING</unmanaged-short>
        </member>
        <member name="T:SharpDX.DirectManipulation.DManip">
            <summary>
            Functions
            </summary>
        </member>
        <member name="T:SharpDX.DirectManipulation.PointerId">
            <summary>
            Functions
            </summary>
        </member>
        <member name="F:SharpDX.DirectManipulation.PointerId.KeyboardFocus">
            <summary>Constant KeyboardFocus</summary>
            <unmanaged>DIRECTMANIPULATION_KEYBOARDFOCUS</unmanaged>
        </member>
        <member name="F:SharpDX.DirectManipulation.PointerId.MouseFocus">
            <summary>Constant MouseFocus</summary>
            <unmanaged>DIRECTMANIPULATION_MOUSEFOCUS</unmanaged>
        </member>
        <member name="F:SharpDX.DirectManipulation.PointerId.MinimumZoom">
            <summary>Constant MinimumZoom</summary>
            <unmanaged>DIRECTMANIPULATION_MINIMUM_ZOOM</unmanaged>
        </member>
        <member name="M:SharpDX.DirectManipulation.Compositor2.AddContentWithCrossProcessChaining(SharpDX.DirectManipulation.PrimaryContent,SharpDX.IUnknown,SharpDX.IUnknown,SharpDX.IUnknown)">
            <summary>
            <p>Associates content (owned by the component host) with the compositor, assigns a composition device to the content, and specifies the position of the content in the composition tree relative to other composition visuals. Represents a compositor object that associates manipulated content with drawing surfaces across multiple processes.</p>
            </summary>
            <param name = "content"><dd> <p>The content to add to the composition tree.</p> <p><em>content</em> is placed  between <em>parentVisual</em> and <em>childVisual</em> in the composition tree. </p> <p>Only primary content, created at the same time as the viewport, is valid.</p> </dd></param>
            <param name = "device"><dd> <p>The device used to compose the content. </p> <strong>Note</strong>??<em>device</em> is created by the application. ? </dd></param>
            <param name = "arentVisualRef"><dd> <p>The parent visuals in the composition tree of the content being added.</p> <p><em>parentVisual</em> must also be a parent of <em>childVisual</em> in the composition tree.</p> </dd></param>
            <param name = "childVisual"><dd> <p>The child visuals in the composition tree of the content being added.</p> <p><em>parentVisual</em> must also be a parent of <em>childVisual</em> in the composition tree.</p> </dd></param>
            <returns><p>If the method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>This method inserts a small visual tree (owned by the Direct Manipulation device) between the <em>parentVisual</em> and the <em>childVisual</em>. Transforms can then be applied to the inserted content.  
            </p><p>All content, regardless of type, must be added to the compositor. </p><p>If the application uses a system-provided <strong><see cref = "T:SharpDX.DirectManipulation.Compositor"/></strong>:</p><ul> <li><em>device</em> must be an  <strong><see cref = "!:SharpDX.DirectComposition.Device"/></strong> object, and parent and child visuals must be <strong><see cref = "!:SharpDX.DirectComposition.Visual"/></strong> objects.</li> <li><em>device</em>, <em>parentVisual</em>, and <em>childVisual</em> cannot be <c>null</c>. </li> <li><em>device</em>, <em>parentVisual</em>, and <em>childVisual</em> objects are created and owned by the application.
            </li> <li>When content is added to the composition tree using this method, the new composition visuals are inserted between <em>parentVisual</em> and <em>childVisual</em>. The new visuals should not be destroyed until they are disassociated from the compositor with <strong>RemoveContent</strong>.</li> </ul><p>If the application uses a custom implementation of <strong><see cref = "T:SharpDX.DirectManipulation.Compositor"/></strong>:</p><ul> <li><em>device</em>, <em>parentVisual</em>, and <em>childVisual</em> must be a valid type for the compositor. They do not have to be <strong><see cref = "!:SharpDX.DirectComposition.Device"/></strong> or <strong><see cref = "!:SharpDX.DirectComposition.Visual"/></strong> objects.</li> <li><em>device</em>, <em>parentVisual</em>, and <em>childVisual</em> can be <c>null</c>, depending on the compositor. </li> </ul><p>The cross-process reference events (<strong>WM_POINTERROUTEDAWAY</strong>, <strong>WM_POINTERROUTEDRELEASED</strong>, and <strong>WM_POINTERROUTEDTO</strong>) should be handled appropriately. </p>
            </remarks>
            <doc-id>mt622455</doc-id>
            <unmanaged>HRESULT IDirectManipulationCompositor2::AddContentWithCrossProcessChaining([In] IDirectManipulationPrimaryContent* content,[In, Optional] IUnknown* device,[In, Optional] IUnknown* parentVisual,[In, Optional] IUnknown* childVisual)</unmanaged>
            <unmanaged-short>IDirectManipulationCompositor2::AddContentWithCrossProcessChaining</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectManipulation.DeferContactService.DeferContact(System.Int32,System.Int32)">
            <summary>
            <p>Specifies the amount of time to defer the execution of a call to <strong>SetContact</strong> for this <em>referenceId</em>.</p><p><strong>DeferContact</strong> must be called before <strong>SetContact</strong>.</p>
            </summary>
            <param name = "pointerId">No documentation.</param>
            <param name = "timeout">No documentation.</param>
            <returns><p>If the method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dn972380</doc-id>
            <unmanaged>HRESULT IDirectManipulationDeferContactService::DeferContact([In] unsigned int pointerId,[In] unsigned int timeout)</unmanaged>
            <unmanaged-short>IDirectManipulationDeferContactService::DeferContact</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectManipulation.DeferContactService.CancelContact(System.Int32)">
            <summary>
            <p>Cancel all scheduled calls to <strong>SetContact</strong> for this <em>referenceId</em>.    </p>
            </summary>
            <param name = "pointerId">No documentation.</param>
            <returns><p>If the method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>This function fails if the timeout specified in <strong>DeferContact</strong> has already been reached.  </p>
            </remarks>
            <doc-id>dn972378</doc-id>
            <unmanaged>HRESULT IDirectManipulationDeferContactService::CancelContact([In] unsigned int pointerId)</unmanaged>
            <unmanaged-short>IDirectManipulationDeferContactService::CancelContact</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectManipulation.DeferContactService.CancelDeferral(System.Int32)">
            <summary>
            <p>Cancel the deferral set in <strong>DeferContact</strong> and process the scheduled <strong>SetContact</strong> call for this <em>referenceId</em>.    </p>
            </summary>
            <param name = "pointerId">No documentation.</param>
            <returns><p>If the method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dn972379</doc-id>
            <unmanaged>HRESULT IDirectManipulationDeferContactService::CancelDeferral([In] unsigned int pointerId)</unmanaged>
            <unmanaged-short>IDirectManipulationDeferContactService::CancelDeferral</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectManipulation.DragDropEventHandler.OnDragDropStatusChange(SharpDX.DirectManipulation.Viewport2,SharpDX.DirectManipulation.DragDropStatus,SharpDX.DirectManipulation.DragDropStatus)">
            <summary>
            <p>Called when a status change happens in the viewport that the drag-and-drop behavior is attached to. </p>
            </summary>
            <param name = "viewport"><dd> <p>The updated viewport.</p> </dd></param>
            <param name = "current"><dd> <p>The current state of the drag-drop interaction from <strong><see cref = "T:SharpDX.DirectManipulation.DragDropStatus"/></strong>. </p> </dd></param>
            <param name = "previous"><dd> <p>The previous state of the drag-drop interaction from <strong><see cref = "T:SharpDX.DirectManipulation.DragDropStatus"/></strong>. </p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>If a class  is implementing <strong><see cref = "T:SharpDX.DirectManipulation.ViewportEventHandler"/></strong> it should also implement <strong><see cref = "T:SharpDX.DirectManipulation.DragDropEventHandler"/></strong> if that viewport will use drag and drop. Direct Manipulation will query the <strong><see cref = "T:SharpDX.DirectManipulation.ViewportEventHandler"/></strong> instances to verify that  they also implement <strong><see cref = "T:SharpDX.DirectManipulation.DragDropEventHandler"/></strong>.
            </p>
            </remarks>
            <doc-id>dn280393</doc-id>
            <unmanaged>HRESULT IDirectManipulationDragDropEventHandler::OnDragDropStatusChange([In] IDirectManipulationViewport2* viewport,[In] DIRECTMANIPULATION_DRAG_DROP_STATUS current,[In] DIRECTMANIPULATION_DRAG_DROP_STATUS previous)</unmanaged>
            <unmanaged-short>IDirectManipulationDragDropEventHandler::OnDragDropStatusChange</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectManipulation.FrameInfoProvider.GetNextFrameInfo(System.Int64@,System.Int64@,System.Int64@)">
            <summary>
            <p>Retrieves the composition timing information from the compositor.</p>
            </summary>
            <param name = "time"><dd> <p>The current time, in milliseconds.</p> </dd></param>
            <param name = "rocessTimeRef"><dd> <p>The time, in milliseconds, when the compositor begins constructing the next frame.</p> </dd></param>
            <param name = "compositionTime"><dd> <p>The time, in milliseconds, when the compositor finishes composing and drawing the next frame on the screen.</p> </dd></param>
            <returns><p>If the method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>The system implementation of <strong><see cref = "T:SharpDX.DirectManipulation.FrameInfoProvider"/></strong> uses DirectComposition. <strong>GetFrameStatistics</strong> is used to calculate the parameter values for <strong>GetNextFrameInfo</strong>.</p>
            </remarks>
            <doc-id>hh446977</doc-id>
            <unmanaged>HRESULT IDirectManipulationFrameInfoProvider::GetNextFrameInfo([Out] unsigned longlong* time,[Out] unsigned longlong* processTime,[Out] unsigned longlong* compositionTime)</unmanaged>
            <unmanaged-short>IDirectManipulationFrameInfoProvider::GetNextFrameInfo</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectManipulation.InteractionEventHandler.OnInteraction(SharpDX.DirectManipulation.Viewport2,SharpDX.DirectManipulation.InteractionType)">
            <summary>
            <p>Called when an interaction is detected.</p>
            </summary>
            <param name = "viewport"><dd> <p>The viewport on which the interaction was detected.</p> </dd></param>
            <param name = "interaction"><dd> <p>One of the values from <strong><see cref = "T:SharpDX.DirectManipulation.InteractionType"/></strong>.</p> </dd></param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>dn280395</doc-id>
            <unmanaged>HRESULT IDirectManipulationInteractionEventHandler::OnInteraction([In] IDirectManipulationViewport2* viewport,[In] DIRECTMANIPULATION_INTERACTION_TYPE interaction)</unmanaged>
            <unmanaged-short>IDirectManipulationInteractionEventHandler::OnInteraction</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectManipulation.Manager3.GetService(System.Guid,System.Guid,System.IntPtr@)">
            <summary>
            <p>Retrieves an <strong><see cref = "T:SharpDX.DirectManipulation.DeferContactService"/></strong> object.</p>
            </summary>
            <param name = "clsid">No documentation.</param>
            <param name = "riid">No documentation.</param>
            <param name = "@object">No documentation.</param>
            <returns><p>If the method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>mt622457</doc-id>
            <unmanaged>HRESULT IDirectManipulationManager3::GetService([In] const GUID&amp; clsid,[In] const GUID&amp; riid,[Out] void** object)</unmanaged>
            <unmanaged-short>IDirectManipulationManager3::GetService</unmanaged-short>
        </member>
        <member name="P:SharpDX.DirectManipulation.PrimaryContent.HorizontalAlignment">
            <summary>
            <p>Sets the horizontal alignment of the primary content relative to the viewport.</p>
            </summary>
            <remarks>
            <p>If you have activated a configuration consisting only of zoom or zoom inertia, specify DIRECTMANIPULATION_HORIZONTALALIGNMENT_UNLOCKCENTER to respect the zoom center point.</p>
            </remarks>
            <doc-id>hh768909</doc-id>
            <unmanaged>SetHorizontalAlignment</unmanaged>
            <unmanaged-short>SetHorizontalAlignment</unmanaged-short>
        </member>
        <member name="P:SharpDX.DirectManipulation.PrimaryContent.VerticalAlignment">
            <summary>
            <p>Specifies the vertical alignment of the primary content in the viewport.</p>
            </summary>
            <remarks>
            <p>If you have activated a configuration consisting only of zoom or zoom inertia, specify <strong>DIRECTMANIPULATION_VERTICALALIGNMENT_UNLOCKCENTER</strong> to respect the zoom center point.</p>
            </remarks>
            <doc-id>hh768914</doc-id>
            <unmanaged>SetVerticalAlignment</unmanaged>
            <unmanaged-short>SetVerticalAlignment</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectManipulation.PrimaryContent.SetSnapInterval(SharpDX.DirectManipulation.MotionTypes,System.Single,System.Single)">
            <summary>
            <p> Specifies snap points for the inertia end position at uniform intervals.</p>
            </summary>
            <param name = "motion"><dd> <p>One of the <strong><see cref = "T:SharpDX.DirectManipulation.MotionTypes"/></strong> enumeration values.</p> </dd></param>
            <param name = "interval"><dd> <p>The interval between each snap point.</p> </dd></param>
            <param name = "offset"><dd> <p>The offset from the coordinate specified in <strong>SetSnapCoordinate</strong>.</p> </dd></param>
            <returns><p>If the method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>Snap point locations are in content coordinate units. </p><p>Specify snap points through <strong>SetSnapPoints</strong> or <strong>SetSnapInterval</strong>. </p><p>If snap points are invalid (for example, outside of the content boundaries), they are ignored and the content is always within the content boundaries. </p><p>Snap points are not at boundaries by default. If you wish for content to stop at a boundary, a snap point must be set at the boundary.</p><p> Snap points set by <strong>SetSnapInterval</strong> can be cleared by calling <strong>SetSnapInterval</strong> with an interval of 0.0f.</p>
            </remarks>
            <doc-id>hh768911</doc-id>
            <unmanaged>HRESULT IDirectManipulationPrimaryContent::SetSnapInterval([In] DIRECTMANIPULATION_MOTION_TYPES motion,[In] float interval,[In] float offset)</unmanaged>
            <unmanaged-short>IDirectManipulationPrimaryContent::SetSnapInterval</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectManipulation.PrimaryContent.SetSnapPoints(SharpDX.DirectManipulation.MotionTypes,System.Single[],System.Int32)">
            <summary>
            <p>Specifies the snap points for the inertia rest position.</p>
            </summary>
            <param name = "motion"><dd> <p>One or more of the <strong><see cref = "T:SharpDX.DirectManipulation.MotionTypes"/></strong> enumeration values. Only <strong>DIRECTMANIPULATION_MOTION_TRANSLATE_X</strong>, <strong>DIRECTMANIPULATION_MOTION_TRANSLATE_Y</strong>, or <strong>DIRECTMANIPULATION_MOTION_ZOOM</strong> are allowed.</p> </dd></param>
            <param name = "ointsRef"><dd> <p>An array of snap points within the boundaries of the content to snap to. Should be specified in increasing order relative to the origin set in <strong>SetSnapCoordinate</strong>.</p> </dd></param>
            <param name = "pointCount"><dd> <p> The size of the array of snap points. Should be greater than 0.</p> </dd></param>
            <returns><p>If the method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. If there is no change in the snap points, this method can return <strong>S_FALSE</strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code. If invalid snap points are specified, existing snap points might be affected.</p></returns>
            <remarks>
            <p>If snap points are invalid (for example, outside of the content boundaries), they are ignored and the content is always within the content boundaries. </p>
            </remarks>
            <doc-id>hh768912</doc-id>
            <unmanaged>HRESULT IDirectManipulationPrimaryContent::SetSnapPoints([In] DIRECTMANIPULATION_MOTION_TYPES motion,[In, Buffer, Optional] const float* points,[In] DWORD pointCount)</unmanaged>
            <unmanaged-short>IDirectManipulationPrimaryContent::SetSnapPoints</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectManipulation.PrimaryContent.SetSnapType(SharpDX.DirectManipulation.MotionTypes,SharpDX.DirectManipulation.SnapPointType)">
            <summary>
            <p>Specifies the type of snap point.</p>
            </summary>
            <param name = "motion"><dd> <p>One or more of the <strong><see cref = "T:SharpDX.DirectManipulation.MotionTypes"/></strong> enumeration values.</p> </dd></param>
            <param name = "type"><dd> <p>One of the <strong><see cref = "T:SharpDX.DirectManipulation.SnapPointType"/></strong> enumeration values.</p> <p>If set to <strong>DIRECTMANIPULATION_SNAPPOINT_TYPE_NONE</strong>, snap points specified through <strong>SetSnapPoints</strong> or <strong>SetSnapInterval</strong> are cleared.</p> </dd></param>
            <returns><p>If the method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>hh768913</doc-id>
            <unmanaged>HRESULT IDirectManipulationPrimaryContent::SetSnapType([In] DIRECTMANIPULATION_MOTION_TYPES motion,[In] DIRECTMANIPULATION_SNAPPOINT_TYPE type)</unmanaged>
            <unmanaged-short>IDirectManipulationPrimaryContent::SetSnapType</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectManipulation.PrimaryContent.SetSnapCoordinate(SharpDX.DirectManipulation.MotionTypes,SharpDX.DirectManipulation.SnapPointCoordinate,System.Single)">
            <summary>
            <p> Specifies the coordinate system for snap points or snap intervals. </p>
            </summary>
            <param name = "motion"><dd> <p>One of the values from <strong><see cref = "T:SharpDX.DirectManipulation.MotionTypes"/></strong>. </p> </dd></param>
            <param name = "coordinate"><dd> <p>One of the values from <strong><see cref = "T:SharpDX.DirectManipulation.SnapPointCoordinate"/></strong>. </p> <p>If <em>motion</em> is set to translation (<strong>DIRECTMANIPULATION_MOTION_TRANSLATEX</strong> or <strong>DIRECTMANIPULATION_MOTION_TRANSLATEY</strong>), all values of <strong><see cref = "T:SharpDX.DirectManipulation.SnapPointCoordinate"/></strong> are valid. </p> <p>If <em>motion</em> is set to <strong>DIRECTMANIPULATION_MOTION_ZOOM</strong>, only <strong>DIRECTMANIPULATION_COORDINATE_ORIGIN</strong> of <strong><see cref = "T:SharpDX.DirectManipulation.SnapPointCoordinate"/></strong> is valid (<em>origin</em> must be set to 0.0f).</p> </dd></param>
            <param name = "origin"><dd> <p>The initial, or starting, snap point. All snap points are relative to this one. Only used when  <strong>DIRECTMANIPULATION_COORDINATE_ORIGIN</strong> is set. </p> <p>If <em>motion</em> is set to <strong>DIRECTMANIPULATION_MOTION_ZOOM</strong>, then <em>origin</em> must be set to 0.0f.</p> </dd></param>
            <returns><p>If the method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>The origin is relative to the content boundaries. If no boundary has been set (<strong>SetContentRect</strong> is never called) the default boundaries are (-FLT_MAX, FLT_MAX). </p>
            </remarks>
            <doc-id>hh768910</doc-id>
            <unmanaged>HRESULT IDirectManipulationPrimaryContent::SetSnapCoordinate([In] DIRECTMANIPULATION_MOTION_TYPES motion,[In] DIRECTMANIPULATION_SNAPPOINT_COORDINATE coordinate,[In] float origin)</unmanaged>
            <unmanaged-short>IDirectManipulationPrimaryContent::SetSnapCoordinate</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectManipulation.PrimaryContent.SetZoomBoundaries(System.Single,System.Single)">
            <summary>
            <p>Specifies the minimum and maximum boundaries for zoom.</p>
            </summary>
            <param name = "zoomMinimum"><dd> <p>The minimum zoom level allowed. Must be greater than or equal to 0.1f, which corresponds to 100% zoom.</p> </dd></param>
            <param name = "zoomMaximum"><dd> <p>The maximum zoom allowed. Must be greater than <em>zoomMinimum</em> and less than FLT_MAX.</p> </dd></param>
            <returns><p>If the method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>If the content is outside the new boundaries, and the viewport is ENABLED or READY, then the content is reset to be within the new boundaries. If inertia configuration is enabled, the reset operation uses an inertia animation. </p>
            </remarks>
            <doc-id>hh768915</doc-id>
            <unmanaged>HRESULT IDirectManipulationPrimaryContent::SetZoomBoundaries([In] float zoomMinimum,[In] float zoomMaximum)</unmanaged>
            <unmanaged-short>IDirectManipulationPrimaryContent::SetZoomBoundaries</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectManipulation.PrimaryContent.SetHorizontalAlignment(SharpDX.DirectManipulation.HorizontalAlignment)">
            <summary>
            <p>Sets the horizontal alignment of the primary content relative to the viewport.</p>
            </summary>
            <param name = "alignment"><dd> <p>One or more values from <strong><see cref = "T:SharpDX.DirectManipulation.HorizontalAlignment"/></strong>. The default is <strong>DIRECTMANIPULATION_HORIZONTALALIGNMENT_NONE</strong>.</p> <strong>Note</strong>??You cannot combine the following options: DIRECTMANIPULATION_HORIZONTALALIGNMENT_LEFT, DIRECTMANIPULATION-HORIZONTALALIGNMENT_CENTER, DIRECTMANIPULATION_HORIZONTALALIGNMENT_RIGHT. DIRECTMANIPULATION_HORIZONTALALIGNMENT_UNLOCKCENTER can be combined with any option but cannot be configured by itself. ? </dd></param>
            <returns><p>If the method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>If you have activated a configuration consisting only of zoom or zoom inertia, specify DIRECTMANIPULATION_HORIZONTALALIGNMENT_UNLOCKCENTER to respect the zoom center point.</p>
            </remarks>
            <doc-id>hh768909</doc-id>
            <unmanaged>HRESULT IDirectManipulationPrimaryContent::SetHorizontalAlignment([In] DIRECTMANIPULATION_HORIZONTALALIGNMENT alignment)</unmanaged>
            <unmanaged-short>IDirectManipulationPrimaryContent::SetHorizontalAlignment</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectManipulation.PrimaryContent.SetVerticalAlignment(SharpDX.DirectManipulation.VerticalAlignment)">
            <summary>
            <p>Specifies the vertical alignment of the primary content in the viewport.</p>
            </summary>
            <param name = "alignment"><dd> <p>One or more values from <strong><see cref = "T:SharpDX.DirectManipulation.VerticalAlignment"/></strong>.</p> <strong>Note</strong>??You cannot combine <strong>DIRECTMANIPULATION_VERTICALALIGNMENT_TOP</strong>, <strong>DIRECTMANIPULATION_VERTICALALIGNMENT_CENTER</strong>, or <strong>DIRECTMANIPULATION_VERTICALALIGNMENT_BOTTOM</strong>. <strong>DIRECTMANIPULATION_VERTICALALIGNMENT_UNLOCKCENTER</strong> can be combined with any option but cannot be configured by itself. ? </dd></param>
            <returns><p>If the method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>If you have activated a configuration consisting only of zoom or zoom inertia, specify <strong>DIRECTMANIPULATION_VERTICALALIGNMENT_UNLOCKCENTER</strong> to respect the zoom center point.</p>
            </remarks>
            <doc-id>hh768914</doc-id>
            <unmanaged>HRESULT IDirectManipulationPrimaryContent::SetVerticalAlignment([In] DIRECTMANIPULATION_VERTICALALIGNMENT alignment)</unmanaged>
            <unmanaged-short>IDirectManipulationPrimaryContent::SetVerticalAlignment</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectManipulation.PrimaryContent.GetInertiaEndTransform(System.Single[],System.Int32)">
            <summary>
            <p>Gets the final transform, including inertia, of the primary content.</p>
            </summary>
            <param name = "matrix"><dd> <p>The transformed matrix that represents the inertia ending position.</p> </dd></param>
            <param name = "pointCount"><dd> <p>The size of the matrix. </p> <p> This value is always 6, because a 3x2 matrix is used for all direct manipulation transforms.</p> </dd></param>
            <returns><p>If the method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <strong>Warning</strong>??Calling this method can cause a race condition if inertia has ended or been interrupted. This can also occur during the <strong>OnViewportStatusChanged</strong> callback.?
            </remarks>
            <doc-id>hh768908</doc-id>
            <unmanaged>HRESULT IDirectManipulationPrimaryContent::GetInertiaEndTransform([Out, Buffer] float* matrix,[In] DWORD pointCount)</unmanaged>
            <unmanaged-short>IDirectManipulationPrimaryContent::GetInertiaEndTransform</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectManipulation.PrimaryContent.GetCenterPoint(System.Single@,System.Single@)">
            <summary>
            <p> Retrieves the center point of the manipulation in content coordinates. If there is no manipulation in progress, retrieves the center point of the viewport.</p>
            </summary>
            <param name = "centerX"><dd> <p>The center on the horizontal axis.</p> </dd></param>
            <param name = "centerY"><dd> <p>The center on the vertical axis.</p> </dd></param>
            <returns><p>If the method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>hh768907</doc-id>
            <unmanaged>HRESULT IDirectManipulationPrimaryContent::GetCenterPoint([Out] float* centerX,[Out] float* centerY)</unmanaged>
            <unmanaged-short>IDirectManipulationPrimaryContent::GetCenterPoint</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectManipulation.UpdateHandler.Update">
            <summary>
            <p>Notifies the compositor when to update inertia animation.</p>
            </summary>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>hh447130</doc-id>
            <unmanaged>HRESULT IDirectManipulationUpdateHandler::Update()</unmanaged>
            <unmanaged-short>IDirectManipulationUpdateHandler::Update</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectManipulation.UpdateManager.RegisterWaitHandleCallback(System.IntPtr,SharpDX.DirectManipulation.UpdateHandler,System.Int32@)">
            <summary>
            <p>Registers a callback that is triggered by a handle.</p>
            </summary>
            <param name = "handle"><dd> <p>The event handle that triggers the callback.</p> </dd></param>
            <param name = "eventHandler"><dd> <p>The event handler to call when the event is fired.</p> </dd></param>
            <param name = "cookie"><dd> <p>The unique ID of the event callback instance.</p> </dd></param>
            <returns><p>If the method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>hh447134</doc-id>
            <unmanaged>HRESULT IDirectManipulationUpdateManager::RegisterWaitHandleCallback([In] void* handle,[In] IDirectManipulationUpdateHandler* eventHandler,[Out] DWORD* cookie)</unmanaged>
            <unmanaged-short>IDirectManipulationUpdateManager::RegisterWaitHandleCallback</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectManipulation.UpdateManager.UnregisterWaitHandleCallback(System.Int32)">
            <summary>
            <p>Deregisters a callback.</p>
            </summary>
            <param name = "cookie"><dd> <p>The unique ID of the event callback instance.</p> </dd></param>
            <returns><p>If the method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <doc-id>hh447136</doc-id>
            <unmanaged>HRESULT IDirectManipulationUpdateManager::UnregisterWaitHandleCallback([In] DWORD cookie)</unmanaged>
            <unmanaged-short>IDirectManipulationUpdateManager::UnregisterWaitHandleCallback</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectManipulation.UpdateManager.Update(SharpDX.DirectManipulation.FrameInfoProvider)">
            <summary>
            <p>Updates Direct Manipulation at the current time.</p>
            </summary>
            <param name = "frameInfo">No documentation.</param>
            <returns><p>If this method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>If the application provides its own implementation of <strong><see cref = "T:SharpDX.DirectManipulation.Compositor"/></strong>, this implementation should call <strong>Update</strong> whenever there is a compositor update. Frame timing information can be provided to Direct Manipulation through the <strong><see cref = "T:SharpDX.DirectManipulation.FrameInfoProvider"/></strong> interface.</p>
            </remarks>
            <doc-id>hh447142</doc-id>
            <unmanaged>HRESULT IDirectManipulationUpdateManager::Update([In, Optional] IDirectManipulationFrameInfoProvider* frameInfo)</unmanaged>
            <unmanaged-short>IDirectManipulationUpdateManager::Update</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectManipulation.ViewportEventHandler.OnViewportStatusChanged(SharpDX.DirectManipulation.Viewport,SharpDX.DirectManipulation.Status,SharpDX.DirectManipulation.Status)">
            <summary>
            <p>Called when the status of a viewport changes.</p>
            </summary>
            <param name = "viewport"><dd> <p>The viewport for which status has changed.</p> </dd></param>
            <param name = "current"><dd> <p>The new status of the viewport.</p> </dd></param>
            <param name = "previous"><dd> <p>The previous status of the viewport.</p> </dd></param>
            <returns><p>If the method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>If you call <strong>GetStatus</strong> from within this handler, the status returned is not guaranteed to be the same as at the time of the call. This is because of the asynchronous nature of the notification.</p>
            </remarks>
            <doc-id>hh447150</doc-id>
            <unmanaged>HRESULT IDirectManipulationViewportEventHandler::OnViewportStatusChanged([In] IDirectManipulationViewport* viewport,[In] DIRECTMANIPULATION_STATUS current,[In] DIRECTMANIPULATION_STATUS previous)</unmanaged>
            <unmanaged-short>IDirectManipulationViewportEventHandler::OnViewportStatusChanged</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectManipulation.ViewportEventHandler.OnViewportUpdated(SharpDX.DirectManipulation.Viewport)">
            <summary>
            <p>Called after all content in the viewport has been updated.</p>
            </summary>
            <param name = "viewport"><dd> <p>The viewport that has been updated.</p> </dd></param>
            <returns><p>If the method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>If you have actions that need to be executed once for a viewport update, implement <strong>OnViewportUpdated</strong>. <strong>OnContentUpdated</strong> is called once for each  content change in the viewport. This can result in multiple <strong>OnContentUpdated</strong> calls. </p>
            </remarks>
            <doc-id>hh447152</doc-id>
            <unmanaged>HRESULT IDirectManipulationViewportEventHandler::OnViewportUpdated([In] IDirectManipulationViewport* viewport)</unmanaged>
            <unmanaged-short>IDirectManipulationViewportEventHandler::OnViewportUpdated</unmanaged-short>
        </member>
        <member name="M:SharpDX.DirectManipulation.ViewportEventHandler.OnContentUpdated(SharpDX.DirectManipulation.Viewport,SharpDX.DirectManipulation.Content)">
            <summary>
            <p>Called when content inside a viewport is updated.
            </p>
            </summary>
            <param name = "viewport"><dd> <p>The viewport that is updated.</p> </dd></param>
            <param name = "content"><dd> <p>The content in the viewport that has changed.</p> </dd></param>
            <returns><p>If the method succeeds, it returns <strong><see cref = "F:SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "T:SharpDX.Result"/></strong> error code.</p></returns>
            <remarks>
            <p>This method is called once for each  content change in the viewport. This can result in multiple <strong>OnContentUpdated</strong> calls. For instance, when the position of the content is changed, you can use <strong>IDirectManipualtionContent::GetContentTransform</strong> to retrieve the new value.</p><p>If you have actions that need to be executed once for a viewport update, implement <strong>OnViewportUpdated</strong>.</p>
            </remarks>
            <doc-id>hh447148</doc-id>
            <unmanaged>HRESULT IDirectManipulationViewportEventHandler::OnContentUpdated([In] IDirectManipulationViewport* viewport,[In] IDirectManipulationContent* content)</unmanaged>
            <unmanaged-short>IDirectManipulationViewportEventHandler::OnContentUpdated</unmanaged-short>
        </member>
    </members>
</doc>
